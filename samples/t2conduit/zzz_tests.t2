;; t2conduit/tests.t2
;; Comprehensive test suite for t2conduit

(program

  (console.log "start")

  ;; Minimal test helpers (avoid external deps for t2run)
  (const* ((describe (lambda ((name) (fn)) (call fn)))
           (it (lambda ((name) (fn)) (console.log name) (call fn)))))

  (defmacro expect (var)
   (quasiquote
      (object
        ("toBe" (lambda ((expected))
          (if (!== expected (unquote var))
          (block
            (console.log (template "toBe fail: " (unquote (String var)) " = " (unquote var)))
            (return false)
          )
          (return true))))
        ("toEqual" (lambda ((expected))
          (if (!= expected (unquote var))
          (block
            (console.log (template "toBe fail: " (unquote (String var)) " = " (unquote var)))
            (return false)
          )
          (return true))))
      )))
  (console.log (call (prop (expect 5) "toBe") 4))
  (console.log (call (prop (expect "4") "toEqual") 4))

  (import (import-spec "./core"
           (named
             from
             fromArray
             fromLazyPromise
             empty
             range
             repeat
             map
             filter
             take
             drop
             takeWhile
             dropWhile
             chunk
             flatMap
             tap
             scan
             collect
             first
             last
             reduce
             count
             some
             every
             forEach
             drain
             distinct)))

  (import (import-spec "./operators"
           (named
             concat
             zip
             catchError
             retry
             defaultIfEmpty
             distinctUntilChanged
             pairwise)))

  (import (import-spec "./interop"
           (named fromPromise toPromise isSource)))

  ;; Runtime pipeline helper (macro-free)
  (const* ((run
           (lambda async ((source: any) (rest ops (t:ref Array (array (t:ref Function)))))
             (let* ((result source))
               (block
                 (for of (op ops)
                   (assign result (call op result)))
                 (return (await result))))))))

  (const* ((index
           (lambda ((items: Array<any>) (i: number))
             (return (call (prop items "find")
                           (lambda ((item) (idx)) :(idx === i))))))))

  ;; ============================================================================
  ;; SOURCE TESTS
  ;; ============================================================================
  
  (call describe "Source Constructors"
    (lambda ()
      (block
        (call it "fromArray should emit all items"
          (fn async ()
            (const* ((result (run (fromArray (array 1 2 3))
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 1 2 3)))))
        
        (call it "fromLazyPromise should not execute until consumed"
          (fn async ()
            (let* ((executed false))
              (const* ((source (fromLazyPromise
                                 (lambda ()
                                   (block
                                     (assign executed true)
                                     (return (call (prop Promise "resolve") 42)))))))
                (block
                  (call (prop (expect executed) "toBe") false)
                  (const* ((result (run source (first))))
                    (block
                      (call (prop (expect executed) "toBe") true)
                      (call (prop (expect result) "toBe") 42))))))))
        
        (call it "empty should emit no values"
          (fn async ()
            (const* ((result (run (empty) (collect))))
              (call (prop (expect result) "toEqual") (array)))))
        
        (call it "range should generate numeric sequence"
          (fn async ()
            (const* ((result (run (range 0 5 1) (collect))))
              (call (prop (expect result) "toEqual") (array 0 1 2 3 4)))))
        
        (call it "repeat should repeat value n times"
          (fn async ()
            (const* ((result (run (repeat "x" 3) (collect))))
              (call (prop (expect result) "toEqual") (array "x" "x" "x"))))))))

  ;; ============================================================================
  ;; PIPE OPERATOR TESTS
  ;; ============================================================================
  
  (call describe "Pipe Operators"
    (lambda ()
      (block
        (call it "map should transform each value"
          (fn async ()
            (const* ((result (run (from (array 1 2 3))
                                  (map (lambda ((x)) :(x * 2)))
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 2 4 6)))))
        
        (call it "filter should keep matching values"
          (fn async ()
            (const* ((result (run (from (array 1 2 3 4 5))
                                  (filter (lambda ((x)) :(x % 2 === 0)))
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 2 4)))))
        
        (call it "take should limit values"
          (fn async ()
            (const* ((result (run (range 0 100 1)
                                  (take 5)
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 0 1 2 3 4)))))
        
        (call it "drop should skip values"
          (fn async ()
            (const* ((result (run (from (array 1 2 3 4 5))
                                  (drop 2)
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 3 4 5)))))
        
        (call it "takeWhile should take until predicate fails"
          (fn async ()
            (const* ((result (run (from (array 1 2 3 4 5))
                                  (takeWhile (lambda ((x)) :(x < 4)))
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 1 2 3)))))
        
        (call it "dropWhile should drop until predicate fails"
          (fn async ()
            (const* ((result (run (from (array 1 2 3 4 5))
                                  (dropWhile (lambda ((x)) :(x < 3)))
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 3 4 5)))))
        
        (call it "chunk should group values"
          (fn async ()
            (const* ((result (run (from (array 1 2 3 4 5))
                                  (chunk 2)
                                  (collect))))
              (call (prop (expect result) "toEqual")
                    (array (array 1 2) (array 3 4) (array 5))))))
        
        (call it "flatMap should flatten mapped results"
          (fn async ()
            (const* ((result (run (from (array 1 2 3))
                                  (flatMap (lambda ((x))
                                               (call (prop Promise "resolve")
                                                   :(x * 2)))
                                           (object))
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 2 4 6)))))
        
        (call it "tap should execute side effects without modifying stream"
          (fn async ()
            (let* ((sideEffects (array)))
              (const* ((result (run (from (array 1 2 3))
                                    (tap (lambda ((x))
                                           (call (prop sideEffects "push") :(x * 10))))
                                    (collect))))
                (block
                  (call (prop (expect result) "toEqual") (array 1 2 3))
                  (call (prop (expect sideEffects) "toEqual") (array 10 20 30)))))))
        
        (call it "scan should produce running accumulation"
          (fn async ()
            (const* ((result (run (from (array 1 2 3 4))
                                  (scan (lambda ((acc) (x)) :(acc + x)) 0)
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 1 3 6 10)))))
        
        (call it "distinct should remove duplicates"
          (fn async ()
            (const* ((result (run (from (array 1 2 2 3 3 3 4))
                                  (distinct)
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 1 2 3 4))))))))

  ;; ============================================================================
  ;; SINK OPERATOR TESTS
  ;; ============================================================================
  
  (call describe "Sink Operators"
    (lambda ()
      (block
        (call it "collect should gather all values"
          (fn async ()
            (const* ((result (run (from (array 1 2 3)) (collect))))
              (call (prop (expect result) "toEqual") (array 1 2 3)))))
        
        (call it "first should return first value"
          (fn async ()
            (const* ((result (run (from (array 1 2 3)) (first))))
              (call (prop (expect result) "toBe") 1))))
        
        (call it "first should return undefined for empty source"
          (fn async ()
            (const* ((result (run (empty) (first))))
              (call (prop (expect result) "toBe") undefined))))
        
        (call it "last should return last value"
          (fn async ()
            (const* ((result (run (from (array 1 2 3)) (last))))
              (call (prop (expect result) "toBe") 3))))
        
        (call it "reduce should fold stream"
          (fn async ()
            (const* ((result (run (from (array 1 2 3 4))
                                  (reduce (lambda ((acc) (x)) :(acc + x)) 0))))
              (call (prop (expect result) "toBe") 10))))
        
        (call it "count should count values"
          (fn async ()
            (const* ((result (run (from (array 1 2 3 4 5)) (count))))
              (call (prop (expect result) "toBe") 5))))
        
        (call it "some should return true if any match"
          (fn async ()
            (const* ((result (run (from (array 1 2 3 4))
                                  (some (lambda ((x)) :(x > 3))))))
              (call (prop (expect result) "toBe") true))))
        
        (call it "every should return true if all match"
          (fn async ()
            (const* ((result (run (from (array 2 4 6))
                                  (every (lambda ((x)) :(x % 2 === 0))))))
              (call (prop (expect result) "toBe") true))))
        
        (call it "forEach should execute for each value"
          (fn async ()
            (let* ((sum 0))
              (block
                (run (from (array 1 2 3))
                     (forEach (lambda ((x))
                                (assign sum :(sum + x)))))
                 (call (prop (expect sum) "toBe") 6)))))
        
        (call it "drain should consume all values"
          (fn async ()
            (let* ((count 0))
              (block
                (run (from (array 1 2 3))
                     (tap (lambda ((_))
                            (assign count :(count + 1))))
                     (drain))
                 (call (prop (expect count) "toBe") 3))))))))

  ;; ============================================================================
  ;; COMBINING OPERATOR TESTS
  ;; ============================================================================
  
  (call describe "Combining Operators"
    (lambda ()
      (block
        (call it "concat should combine sources sequentially"
          (fn async ()
            (const* ((result (run (concat (from (array 1 2))
                                          (from (array 3 4)))
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 1 2 3 4)))))
        
        (call it "zip should combine pairwise"
          (fn async ()
            (const* ((result (run (zip (from (array 1 2 3))
                                       (from (array "a" "b" "c")))
                                  (collect))))
              (call (prop (expect result) "toEqual")
                    (array (array 1 "a") (array 2 "b") (array 3 "c"))))))
        
        (call it "zip should stop at shortest stream"
          (fn async ()
            (const* ((result (run (zip (from (array 1 2))
                                       (from (array "a" "b" "c")))
                                  (collect))))
              (call (prop (expect result) "toEqual")
                    (array (array 1 "a") (array 2 "b")))))))))

  ;; ============================================================================
  ;; ERROR HANDLING TESTS
  ;; ============================================================================
  
  (call describe "Error Handling"
    (lambda ()
      (block
        (call it "catchError should handle errors"
          (fn async ()
            (const* ((source (call (fn async generator ()
                                       (block
                                         (yield 1)
                                       (throw (new Error "test error"))))))
                     (result (run source
                                  (catchError (lambda ((err))
                                                (return (from (array :(0 - 1))))))
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 1 :(0 - 1))))))
        
        (call it "defaultIfEmpty should provide default for empty stream"
          (fn async ()
            (const* ((result (run (empty)
                                  (defaultIfEmpty 42)
                                  (first))))
              (call (prop (expect result) "toBe") 42))))
        
        (call it "defaultIfEmpty should not affect non-empty stream"
          (fn async ()
            (const* ((result (run (from (array 1 2))
                                  (defaultIfEmpty 42)
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 1 2)))))
        
        (call it "retry should retry on error"
          (fn async ()
            (let* ((attempts 0))
              (const* ((source (call (fn async generator ()
                                       (block
                                         (assign attempts :(attempts + 1))
                                         (if :(attempts < 3)
                                           (throw (new Error "retry me")))
                                           (yield 42)))))
                      (result (run source (retry 3 (object)) (first))))
                (block
                  (call (prop (expect result) "toBe") 42)
                  (call (prop (expect attempts) "toBe") 3)))))))))

  ;; ============================================================================
  ;; ADVANCED PATTERN TESTS
  ;; ============================================================================
  
  (call describe "Advanced Patterns"
    (lambda ()
      (block
        (call it "should handle complex pipeline"
          (fn async ()
            (const* ((result (await (run (range 0 100 1)
                                         (filter (lambda ((x)) :(x % 2 === 0)))
                                         (map (lambda ((x)) :(x * x)))
                                         (take 5)
                                         (scan (lambda ((acc) (x)) :(acc + x)) 0)
                                         (collect)))))
              ;; [0, 4, 20, 56, 120]
              (call (prop (expect (prop result "length")) "toBe") 5))))
        
        (call it "should handle nested sources"
          (fn async ()
            (const* ((result (run (from (array (array 1 2) (array 3 4)))
                                  (flatMap (lambda ((arr))
                                               (call (prop Promise "resolve")
                                                   (call (prop arr "reduce")
                                                         (lambda ((a) (b)) :(a + b)))))
                                           (object))
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 3 7)))))
        
        (call it "should support pairwise operations"
          (fn async ()
            (const* ((result (run (from (array 1 2 3 4))
                                  (pairwise)
                                  (map (lambda ((pair)) :((index pair 0) + (index pair 1))))
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 3 5 7)))))
        
        (call it "distinctUntilChanged should only emit when value changes"
          (fn async ()
            (const* ((result (run (from (array 1 1 2 2 2 3 3 1))
                                  (distinctUntilChanged (lambda ((a) (b)) :(a === b)))
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 1 2 3 1))))))

  ;; ============================================================================
  ;; MACRO TESTS
  ;; ============================================================================
  
  (call describe "Macros"
    (lambda ()
      (block
        (call it "run macro should work"
          (fn async ()
            (const* ((result (run (fromArray (array 1 2 3))
                                  (map (lambda ((x)) :(x * 2)))
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 2 4 6)))))
        
        (call it "-> threading macro should work"
          (fn async ()
            (const* ((result (run (from (array 1 2 3 4 5))
                                  (filter (lambda ((x)) :(x > 2)))
                                  (map (lambda ((x)) :(x * 2)))
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 6 8 10)))))
        
        (call it "map-collect macro should work"
          (fn async ()
            (const* ((result (run (from (array 1 2 3))
                                  (map (lambda ((x)) :(x + 1)))
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 2 3 4)))))
        
        (call it "filter-collect macro should work"
          (fn async ()
            (const* ((result (run (from (array 1 2 3 4 5))
                                  (filter (lambda ((x)) :(x % 2 === 0)))
                                  (collect))))
              (call (prop (expect result) "toEqual") (array 2 4))))))))

  ;; ============================================================================
  ;; PERFORMANCE TESTS
  ;; ============================================================================
  
  (call describe "Performance"
    (lambda ()
      (block
        (call it "should handle large streams efficiently"
          (fn async ()
            (const* ((start (call (prop Date "now")))
                     (totalCount (run (range 0 100000 1)
                                 (filter (lambda ((x)) :(x % 2 === 0)))
                                 (map (lambda ((x)) :(x * 2)))
                                 (count)))
                     (elapsed :((call (prop Date "now")) - start)))
              (block
                (call (prop (expect totalCount) "toBe") 50000)
                (call (prop (expect :(elapsed < 1000)) "toBe") true)))))
        
        (call it "should support lazy evaluation"
          (fn async ()
            (let* ((iterations 0))
              (const* ((source (call (fn async generator ()
                                       (let* ((i 0))
                                           (while :(i < 1000000)
                                             (assign iterations :(iterations + 1))
                                             (yield i)
                                           (assign i :(i + 1)))))))
                       (result (await (run source (take 5) (collect)))))
                (block
                  (call (prop (expect (prop result "length")) "toBe") 5)
                  ;; Should only iterate 5 times due to laziness
                  (call (prop (expect iterations) "toBe") 5))))))
        
        (call it "should not load entire stream into memory"
          (fn async ()
            ;; This test verifies backpressure
            (let* ((activeItems 0)
                   (maxActive 0))
              (const* ((result (run (range 0 10000 1)
                                    (tap (lambda ((_))
                                           (assign activeItems :(activeItems + 1))
                                           (if :(activeItems > maxActive)
                                             (assign maxActive activeItems))))
                                    (flatMap (fn async ((x))
                                               (await (call (prop Promise "resolve")))
                                               (assign activeItems :(activeItems - 1))
                                               (return x))
                                             (object))
                                    (count))))
                (block
                  (call (prop (expect result) "toBe") 10000)
                  ;; With proper backpressure, we shouldn't load everything
                  (call (prop (expect :(maxActive < 100)) "toBe") true)))))))))

  ;; ============================================================================
  ;; INTEROP TESTS
  ;; ============================================================================
  
  (call describe "Interop"
    (lambda ()
      (block
        (call it "should convert Promise to Source"
          (fn async ()
            (const* ((promise (call (prop Promise "resolve") 42))
                     (result (run (fromPromise promise) (first))))
              (call (prop (expect result) "toBe") 42))))
        
        (call it "should convert Source to Promise"
          (fn async ()
            (const* ((source (from (array 1 2 3)))
                     (result (await (toPromise source))))
              (call (prop (expect result) "toBe") 1))))
        
        (call it "should check if value is Source"
          (fn async ()
            (const* ((source (from (array 1 2 3))))
              (block
                (call (prop (expect (isSource source)) "toBe") true)
                (call (prop (expect (isSource (array 1 2 3))) "toBe") false)
                (call (prop (expect (isSource 42)) "toBe") false))))))))

  ;; Run all tests
  (call (prop console "log") "All tests defined"))
)
)
