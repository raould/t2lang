(program
  (import (object (:named (array (object (:name "CharStream")) (object (:name "CommonTokenStream"))))) "antlr4ng")
  (import (object (:named (array (object (:name "Stage3DLexer"))))) "./Stage3DLexer")
  (import (object (:named (array (object (:name "StarBindingContext")) (object (:name "SingleBindingContext")) (object (:name "ParamContext")) (object (:name "Stage3DParser"))))) "./Stage3DParser")
  (import (object (:default "fs")) "node:fs")
  (let*
   (
    ;; ========== helpers ==========
    (dbg (lambda ((...msgs)) ((. console error) msgs)))
    (parseString
      (lambda ((tokenText))
        (let* ((raw_ tokenText))
          (if ((. raw_ startsWith) '"""')
            (return ((. raw_ slice) 3 -3)))
          (let* ((inner ((. raw_ slice) 1 -1)))
            (return ((. JSON parse) (+ '"' ((. inner replace) /"/g '\\"') '"')))))))
    (indent
      (lambda ((text))
        (return ((. ((. ((. text split) '\n') map) (lambda ((line)) (return (+ '  ' line)))) join) '\n'))))
    (isDefined
      (lambda ((val))
        (return (!== val undefined))))
    (isOperator
      (lambda ((name))
        (let* ((ops (array "<" ">" "<=" ">=" "&&" "||" "!=" "!==" "==" "==="
                  "+" "-" "*" "/" "%" "^" "!")))
        (return ((. ops includes) name)))))
    ;; ========== Phase A: CST â†’ Surface AST ==========
    (astProgram
      (lambda ((ctx))
        (let* ((body ((. ((. ctx topLevel)) map) astTopLevel)))
          (return (object (tag 'program') (body body))))))
    (astTopLevel
      (lambda ((ctx))
        (if ((. ctx "defmacro"))
          (return (astDefmacro ((. ctx "defmacro")))))
        (if ((. ctx "def"))
          (return (astDef ((. ctx "def")))))
        (return (astStatement ((. ctx statement))))))
    (astDefmacro
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (params ((. ((. ((. ctx fnSignature)) param)) map) (lambda ((p)) (return ((. ((. p IDENTIFIER)) getText))))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'defmacro') (name name) (params params) (body body))))))
    (astDef
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (init (astExpression ((. ctx expression)))))
          (return (object (tag 'def') (name name) (init init))))))
    (astStatement
      (lambda ((ctx))
        (if ((. ctx letStar))
          (return (astLetStar ((. ctx letStar)))))
        (if ((. ctx letStmt))
          (return (astLetStmt ((. ctx letStmt)))))
        (if ((. ctx constStar))
          (return (astConstStar ((. ctx constStar)))))
        (if ((. ctx constStmt))
          (return (astConstStmt ((. ctx constStmt)))))
        (if ((. ctx ifForm))
          (return (astIf ((. ctx ifForm)))))
        (if ((. ctx whileForm))
          (return (astWhile ((. ctx whileForm)))))
        (if ((. ctx block))
          (return (astBlock ((. ctx block)))))
        (if ((. ctx "assign"))
          (return (astAssign ((. ctx "assign")))))
        (if ((. ctx returnForm))
          (return (astReturn ((. ctx returnForm)))))
        (if ((. ctx throwForm))
          (return (astThrow ((. ctx throwForm)))))
        (if ((. ctx importForm))
          (return (astImport ((. ctx importForm)))))
        (if ((. ctx switchForm))
          (return (astSwitch ((. ctx switchForm)))))
        (if ((. ctx forForm))
          (return (astFor ((. ctx forForm)))))
        (if ((. ctx forInForm))
          (return (astForIn ((. ctx forInForm)))))
        (if ((. ctx forOfForm))
          (return (astForOf ((. ctx forOfForm)))))
        (let* ((expr (astExpression ((. ctx expression)))))
          (return (object (tag 'expr-stmt') (expr expr))))))
    (astThrow
      (lambda ((ctx))
        (let* ((expr (astExpression ((. ctx expression)))))
          (return (object (tag 'throw') (expr expr))))))
    (astImport
      (lambda ((ctx))
        (let* ((spec (ternary ((. ctx objectExpr)) (astObjectExpr ((. ctx objectExpr))) undefined))
               (source (parseString ((. ((. ctx STRING)) getText)))))
          (return (object (tag 'import') (spec spec) (source source))))))
    (astSwitch
      (lambda ((ctx))
        (let* ((discriminant (astExpression ((. ctx expression))))
               (cases ((. ((. ctx caseClause)) map) (lambda ((c))
                 (let* ((test (astExpression ((. c expression))))
                        (body ((. ((. c statement)) map) astStatement)))
                   (return (object (test test) (body body)))))))
               (defCtx ((. ctx defaultClause)))
               (defaultCase (ternary defCtx (object (body ((. ((. defCtx statement)) map) astStatement))) undefined)))
          (return (object (tag 'switch') (discriminant discriminant) (cases cases) (defaultCase defaultCase))))))
    (astFor
      (lambda ((ctx))
        (let* ((initCtx ((. ctx letStmt)))
               (bindCtx ((. initCtx singleBinding)))
               (initName ((. ((. bindCtx IDENTIFIER)) getText)))
               (initExpr (astExpression ((. initCtx expression))))
               (test (astExpression ((. ctx expression))))
               (updateCtx ((. ctx "assign")))
               (updateName ((. ((. updateCtx IDENTIFIER)) getText)))
               (updateExpr (astExpression ((. updateCtx expression))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'for') (initName initName) (initExpr initExpr) (test test) (updateName updateName) (updateExpr updateExpr) (body body))))))
    (astForIn
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (obj (astExpression ((. ctx expression))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'for-in') (name name) ("object" obj) (body body))))))
    (astForOf
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (iterable (astExpression ((. ctx expression))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'for-of') (name name) (iterable iterable) (body body))))))
    (astLetStar
      (lambda ((ctx))
        (let* ((bindings ((. ((. ctx starBinding)) map) (lambda ((b))
                 (let* ((id ((. ((. b IDENTIFIER)) getText)))
                        (init (astExpression ((. b expression))))
                        (typeAnnotation (ternary ((. b typeExpr)) (astTypeExpr ((. b typeExpr))) undefined)))
                   (return (object (name id) (init init) (typeAnnotation typeAnnotation)))))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'let*') (bindings bindings) (body body))))))
    (astLetStmt
      (lambda ((ctx))
        (let* ((bindCtx ((. ctx singleBinding)))
               (name ((. ((. bindCtx IDENTIFIER)) getText)))
               (typeAnnotation (ternary ((. bindCtx typeExpr)) (astTypeExpr ((. bindCtx typeExpr))) undefined))
               (init (astExpression ((. ctx expression)))))
          (return (object (tag 'let') (name name) (typeAnnotation typeAnnotation) (init init))))))
    (astConstStar
      (lambda ((ctx))
        (let* ((bindings ((. ((. ctx starBinding)) map) (lambda ((b))
                 (let* ((id ((. ((. b IDENTIFIER)) getText)))
                        (init (astExpression ((. b expression))))
                        (typeAnnotation (ternary ((. b typeExpr)) (astTypeExpr ((. b typeExpr))) undefined)))
                   (return (object (name id) (init init) (typeAnnotation typeAnnotation)))))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'const*') (bindings bindings) (body body))))))
    (astConstStmt
      (lambda ((ctx))
        (let* ((bindCtx ((. ctx singleBinding)))
               (name ((. ((. bindCtx IDENTIFIER)) getText)))
               (typeAnnotation (ternary ((. bindCtx typeExpr)) (astTypeExpr ((. bindCtx typeExpr))) undefined))
               (init (astExpression ((. ctx expression)))))
          (return (object (tag 'const') (name name) (typeAnnotation typeAnnotation) (init init))))))
    (astIf
      (lambda ((ctx))
        (let* ((test (astExpression ((. ctx expression))))
               (ifthen (astStatement ((. ctx statement) 0)))
               (ctxElse ((. ctx statement) 1))
               (ifelse (ternary ctxElse (astStatement ctxElse) undefined)))
          (return (object (tag 'if') (test test) (ifthen ifthen) (ifelse ifelse))))))
    (astWhile
      (lambda ((ctx))
        (let* ((test (astExpression ((. ctx expression))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'while') (test test) (body body))))))
    (astBlock
      (lambda ((ctx))
        (let* ((body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'block') (body body))))))
    (astReturn
      (lambda ((ctx))
        (let* ((expr (ternary ((. ctx expression)) (astExpression ((. ctx expression))) undefined)))
          (return (object (tag 'return') (expr expr))))))
    ;; Stage 3 additions
    (astObjectExpr
      (lambda ((ctx))
        (let* ((fields ((. ((. ctx objectField)) map) (lambda ((f))
                 (let* ((key))
                   (if ((. f IDENTIFIER))
                     (set! key ((. ((. f IDENTIFIER)) getText))))
                   (if ((. f KEYWORD))
                     (set! key ((. ((. f KEYWORD)) getText))))
                   (if ((. f STRING))
                     (set! key (parseString ((. ((. f STRING)) getText)))))
                   (let* ((value (astExpression ((. f expression)))))
                     (return (object (key key) (value value)))))))))
          (return (object (tag 'object') (fields fields))))))
    (astArrayExpr
      (lambda ((ctx))
        (let* ((elements ((. ((. ctx expression)) map) astExpression)))
          (return (object (tag 'array') (elements elements))))))
    (astQuasiquote
      (lambda ((ctx))
        (let* ((expr (astExpression ((. ctx expression)))))
          (return (object (tag 'quasi') (expr expr))))))
    (astUnquote
      (lambda ((ctx))
        (let* ((expr (astExpression ((. ctx expression)))))
          (return (object (tag 'unquote') (expr expr))))))
    (astUnquoteSplicing
      (lambda ((ctx))
        (let* ((expr (astExpression ((. ctx expression)))))
          (return (object (tag 'unquote-splicing') (expr expr))))))
    (astTernary
      (lambda ((ctx))
        (let* ((test (astExpression ((. ctx expression) 0)))
               (ifthen (astExpression ((. ctx expression) 1)))
               (ifelse (astExpression ((. ctx expression) 2))))
          (return (object (tag 'ternary') (test test) (ifthen ifthen) (ifelse ifelse))))))
    (astCondExpr
      (lambda ((ctx))
        (let* ((exprs ((. ((. ctx expression)) map) astExpression))
               (clauses (array))
               (i 0))
          (while (< i (. exprs length))
						((. clauses push) (object (test (index exprs i)) (expr (index exprs (+ i 1)))))
            (set! i (+ i 2)))
          (return (object (tag 'cond') (clauses clauses))))))
    (astNewExpr
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (raw ((. ctx typeArgs)))
               (typeArgs (ternary raw
                             ((. ((. raw typeExpr)) map) astTypeExpr)
                             (array)))
               (args ((. ((. ctx expression)) map) astExpression)))
          (return (object (tag 'new') (name name) (typeArgs typeArgs) (args args))))))
    (astOptChain
      (lambda ((ctx))
        (let* ((obj (astExpression ((. ctx expression))))
               (prop ((. ((. ctx IDENTIFIER)) getText))))
          (return (object (tag 'opt-chain') ("object" obj) (key prop))))))
    (astNullCoalesce
      (lambda ((ctx))
        (let* ((left (astExpression ((. ctx expression) 0)))
               (right (astExpression ((. ctx expression) 1))))
          (return (object (tag 'null-coalesce') (left left) (right right))))))
    (astExpression
      (lambda ((ctx))
        (if (== ctx undefined)
          (begin
            ((. console error) 'astExpression: ctx is undefined or null')
            (return (object (tag 'error') (reason 'ctx undefined')))))
        (if ((. ctx literal))
          (return (astLiteral ((. ctx literal)))))
        (if ((. ctx KEYWORD))
          (return (object (tag 'keyword') (value ((. ((. ctx KEYWORD)) getText))))))
        (if ((. ctx IDENTIFIER))
          (let* ((text ((. ((. ctx IDENTIFIER)) getText))))
            (if ((. text includes) '.')
              (throw (new Error (+ "Invalid use of dotted identifier: " text ". Use (. obj prop) syntax instead."))))
            (return (object (tag 'identifier') (name text)))))
        (if ((. ctx "lambda"))
          (return (astLambda ((. ctx "lambda")))))
        (if ((. ctx objectExpr))
          (return (astObjectExpr ((. ctx objectExpr)))))
        (if ((. ctx arrayExpr))
          (return (astArrayExpr ((. ctx arrayExpr)))))
        (if ((. ctx propAccess))
          (return (astPropAccess ((. ctx propAccess)))))
        (if ((. ctx indexAccess))
          (return (astIndexAccess ((. ctx indexAccess)))))
        (if ((. ctx quasiquote))
          (return (astQuasiquote ((. ctx quasiquote)))))
        (if ((. ctx "unquote"))
          (return (astUnquote ((. ctx "unquote")))))
        (if ((. ctx unquoteSplicing))
          (return (astUnquoteSplicing ((. ctx unquoteSplicing)))))
        (if ((. ctx "ternary"))
          (return (astTernary ((. ctx "ternary")))))
        (if ((. ctx condExpr))
          (return (astCondExpr ((. ctx condExpr)))))
        (if ((. ctx newForm))
          (return (astNewExpr ((. ctx newForm)))))
        (if ((. ctx optChain))
          (return (astOptChain ((. ctx optChain)))))
        (if ((. ctx nullCoalesce))
          (return (astNullCoalesce ((. ctx nullCoalesce)))))
        (if ((. ctx call))
            (return (astCall ((. ctx call)))))
        (throw (new Error (+ 'Unknown expression: ' (ternary (. ctx getText) ((. ctx getText)) ctx))))))
    (astCall
      (lambda ((ctx))
        (let* ((exprs ((. ((. ctx expression)) map) astExpression))
               (raw ((. ctx typeArgs)))
               (typeArgs (ternary raw
                             ((. ((. raw typeExpr)) map) astTypeExpr)
                             (array))))
            (return (object (tag 'call')
                            (fn (index exprs 0))
                            (args ((. exprs slice) 1))
                            (typeArgs typeArgs))))
    (astPropAccess
      (lambda ((ctx))
        (let* ((obj (astExpression ((. ctx expression))))
               (key))
          (if ((. ctx IDENTIFIER))
            (set! key ((. ((. ctx IDENTIFIER)) getText))))
          (if ((. ctx KEYWORD))
            (set! key ((. ((. ctx KEYWORD)) getText))))
          (if ((. ctx STRING))
            (set! key (parseString ((. ((. ctx STRING)) getText)))))
          (return (object (tag 'prop-access') ("object" obj) (key key))))))
    (astIndexAccess
      (lambda ((ctx))
        (let* ((obj (astExpression ((. ctx expression) 0)))
               (idx (astExpression ((. ctx expression) 1))))
          (return (object (tag 'index-access') ("object" obj) ("index" idx))))))
    (astLambda
      (lambda ((ctx))
        (let* ((params ((. ((. ((. ctx fnSignature)) param)) map) (lambda ((p)) (return ((. ((. p IDENTIFIER)) getText))))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'lambda') (params params) (body body))))))
    (astAssign
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (value (astExpression ((. ctx expression)))))
          (return (object (tag "assign") (name name) (value value))))))
                          (typeArgs typeArgs))))))
    (astLiteral
      (lambda ((ctx))
        (if ((. ctx NUMBER))
          (return (object (tag 'literal') (value (Number ((. ((. ctx NUMBER)) getText)))))))
        (if ((. ctx STRING))
          (return (object (tag 'literal') (value (parseString ((. ((. ctx STRING)) getText)))))))
        (if ((. ctx BOOLEAN))
          (return (object (tag 'literal') (value (=== ((. ((. ctx BOOLEAN)) getText)) 'true')))))
        (if ((. ctx NULL))
          (return (object (tag 'literal') (value null))))
        (if ((. ctx UNDEFINED))
          (return (object (tag 'literal') (value undefined))))
        (throw (new Error 'Unknown literal'))))
    ;; ========== Phase A: Type Expressions ==========
    (astTypeExpr
      (lambda ((ctx))
        (if ((. ctx typeUnion))
          (return (astTypeUnion ((. ctx typeUnion)))))
        (if ((. ctx typeIntersection))
          (return (astTypeIntersection ((. ctx typeIntersection)))))
        (if ((. ctx typeArray))
          (return (astTypeArray ((. ctx typeArray)))))
        (if ((. ctx typeTuple))
          (return (astTypeTuple ((. ctx typeTuple)))))
        (if ((. ctx typeFunction))
          (return (astTypeFunction ((. ctx typeFunction)))))
        (if ((. ctx typeObject))
          (return (astTypeObject ((. ctx typeObject)))))
        (if ((. ctx typeLiteral))
          (return (astTypeLiteral ((. ctx typeLiteral)))))
        (if ((. ctx typeKeyof))
          (return (astTypeKeyof ((. ctx typeKeyof)))))
        (if ((. ctx typeTypeof))
          (return (astTypeTypeof ((. ctx typeTypeof)))))
        (if ((. ctx typeIndexAccess))
          (return (astTypeIndexAccess ((. ctx typeIndexAccess)))))
        (if ((. ctx typeConditional))
          (return (astTypeConditional ((. ctx typeConditional)))))
        (if ((. ctx typeInfer))
          (return (astTypeInfer ((. ctx typeInfer)))))
        (if ((. ctx typeMapped))
          (return (astTypeMapped ((. ctx typeMapped)))))
        (if ((. ctx typeTemplateLiteral))
          (return (astTypeTemplateLiteral ((. ctx typeTemplateLiteral)))))
        (if ((. ctx typeApplication))
          (return (astTypeApplication ((. ctx typeApplication)))))
        ;; bare IDENTIFIER
        (if ((. ctx IDENTIFIER))
          (return (object (tag 'type-id') (name ((. ((. ctx IDENTIFIER)) getText))))))
        (throw (new Error (+ 'astTypeExpr: unknown type: ' ((. ctx getText)))))))
    (astTypeUnion
      (lambda ((ctx))
        (let* ((members ((. ((. ctx typeExpr)) map) astTypeExpr)))
          (return (object (tag 'type-union') (members members))))))
    (astTypeIntersection
      (lambda ((ctx))
        (let* ((members ((. ((. ctx typeExpr)) map) astTypeExpr)))
          (return (object (tag 'type-intersection') (members members))))))
    (astTypeArray
      (lambda ((ctx))
        (let* ((element (astTypeExpr ((. ctx typeExpr)))))
          (return (object (tag 'type-array') (element element))))))
    (astTypeTuple
      (lambda ((ctx))
        (let* ((elements ((. ((. ctx typeTupleElement)) map) astTypeTupleElement)))
          (return (object (tag 'type-tuple') (elements elements))))))
    (astTypeTupleElement
      (lambda ((ctx))
        (if ((. ctx REST))
          (return (object (tag 'rest') ("type" (astTypeExpr ((. ctx typeExpr)))))))
        (if (&& ((. ctx IDENTIFIER)) ((. ctx typeExpr)))
          (return (object (tag 'labeled') (name ((. ((. ctx IDENTIFIER)) getText))) ("type" (astTypeExpr ((. ctx typeExpr)))))))
        (return (object (tag 'element') ("type" (astTypeExpr ((. ctx typeExpr))))))))
    (astTypeFunction
      (lambda ((ctx))
        (let* ((tparams (ternary ((. ctx typeParams))
                          ((. ((. ((. ((. ctx typeParams)) typeParamDecl)) map)) astTypeParamDecl))
                          (array)
                        ))
               (params ((. ((. ctx typeFnParam)) map) astTypeFnParam))
               (result (astTypeExpr ((. ((. ctx typeExpr)) at) -1))))
          (return (object (tag 'type-fn') (typeParams tparams) (params params) (result result))))))
    (astTypeFnParam
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (optional (!== ((. ctx OPTIONAL)) undefined))
               (ty (astTypeExpr ((. ctx typeExpr)))))
          (return (object (name name) ("optional" optional) ("type" ty))))))
    (astTypeObject
      (lambda ((ctx))
        (let* ((props ((. ((. ctx typeProp)) map) astTypeProp)))
          (return (object (tag 'type-obj') (props props))))))
    (astTypeProp
      (lambda ((ctx))
        (let* ((isReadonly (> (. ((. ctx propModifier)) length) 0))
               (name ((. ((. ctx IDENTIFIER)) getText)))
               (optional (!== ((. ctx OPTIONAL)) undefined))
               (ty (astTypeExpr ((. ctx typeExpr)))))
          (return (object ("readonly" isReadonly) (name name) ("optional" optional) ("type" ty))))))
    (astTypeLiteral
      (lambda ((ctx))
        (if ((. ctx STRING))
          (return (object (tag 'type-literal') (value (parseString ((. ((. ctx STRING)) getText)))))))
        (if ((. ctx NUMBER))
          (return (object (tag 'type-literal') (value (Number ((. ((. ctx NUMBER)) getText)))))))
        (if ((. ctx BOOLEAN))
          (return (object (tag 'type-literal') (value (=== ((. ((. ctx BOOLEAN)) getText)) 'true')))))
        (throw (new Error 'Unknown type literal'))))
    (astTypeKeyof
      (lambda ((ctx))
        (let* ((operand (astTypeExpr ((. ctx typeExpr)))))
          (return (object (tag 'type-keyof') (operand operand))))))
    (astTypeTypeof
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText))))
          (return (object (tag 'type-typeof') (name name))))))
    (astTypeIndexAccess
      (lambda ((ctx))
        (let* ((obj (astTypeExpr ((. ctx typeExpr) 0)))
               (idx (astTypeExpr ((. ctx typeExpr) 1))))
          (return (object (tag 'type-index') ("object" obj) ("index" idx))))))
    (astTypeConditional
      (lambda ((ctx))
        (let* ((subject (astTypeExpr ((. ctx typeExpr) 0)))
               (constraint (astTypeExpr ((. ctx typeExpr) 1)))
               (trueBranch (astTypeExpr ((. ctx typeExpr) 2)))
               (falseBranch (astTypeExpr ((. ctx typeExpr) 3))))
          (return (object (tag 'type-cond') (subject subject) (constraint constraint) (trueBranch trueBranch) (falseBranch falseBranch))))))
    (astTypeInfer
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText))))
          (return (object (tag 'type-infer') (name name))))))
    (astTypeMapped
      (lambda ((ctx))
        (let* ((binding ((. ((. ctx IDENTIFIER)) getText)))
               (constraint (astTypeExpr ((. ctx typeExpr) 0)))
               (mapfn (lambda ((m)) (return ((. m getText)))))
               (modifiers (ternary ((. ctx mappedModifiers))
                 ((. ((. ((. ctx mappedModifiers)) mappedModifier)) map) mapfn)
                 (array)))
               (value (astTypeExpr ((. ctx typeExpr) 1))))
          (return (object (tag 'type-mapped') (binding binding) (constraint constraint) (modifiers modifiers) (value value))))))
    (astTypeTemplateLiteral
      (lambda ((ctx))
        (let* ((parts ((. ((. ctx templatePart)) map) (lambda ((p))
                 (if ((. p STRING))
                   (return (object (tag 'str') (value (parseString ((. ((. p STRING)) getText))))))
                   (return (object (tag 'type') ("type" (astTypeExpr ((. p typeExpr)))))))))))
          (return (object (tag 'type-template') (parts parts))))))
    (astTypeApplication
      (lambda ((ctx))
        (let* ((allTypes ((. ((. ctx typeExpr)) map) astTypeExpr))
               (callee (index allTypes 0))
               (args ((. allTypes slice) 1)))
          (return (object (tag 'type-app') (callee callee) (args args))))))
    (astTypeParamDecl
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (constraint (ternary ((. ctx typeParamConstraint))
                 (astTypeExpr ((. ((. ctx typeParamConstraint)) typeExpr)))
                 undefined))
               (defaultType (ternary ((. ctx typeParamDefault))
                 (astTypeExpr ((. ((. ctx typeParamDefault)) typeExpr)))
                 undefined)))
          (return (object (name name) (constraint constraint) ("default" defaultType))))))
    ;; ========== Phase B: Lowering ==========
    (lowerProgram
      (lambda ((node))
        (let* ((body ((. (. node body) map) lowerTopLevel)))
          (return (object (tag 'program') (body body))))))
    (lowerTopLevel
      (lambda ((node))
        (if (=== (. node tag) 'defmacro')
          (return (lowerDefmacro node)))
        (if (=== (. node tag) 'def')
          (return (lowerDef node)))
        (return (lowerStmt node))))
    (lowerDefmacro
      (lambda ((node))
        (let* ((body ((. (. node body) map) lowerStmt)))
          (return (object (tag 'defmacro') (name (. node name)) (params (. node params)) (body body))))))
    (lowerDef
      (lambda ((node))
        (let* ((init (lowerExpr (. node init))))
          (return (object (tag 'let-stmt') (name (. node name)) (init init))))))
    (lowerStmt
      (lambda ((node))
        (if (=== (. node tag) 'let*')
          (return (lowerLetStar node)))
        (if (=== (. node tag) 'let')
          (return (object (tag 'let-stmt') (name (. node name)) (typeAnnotation (ternary (. node typeAnnotation) (lowerTypeExpr (. node typeAnnotation)) undefined)) (init (lowerExpr (. node init))))))
        (if (=== (. node tag) 'const*')
          (return (lowerConstStar node)))
        (if (=== (. node tag) 'const')
          (return (object (tag 'const-stmt') (name (. node name)) (typeAnnotation (ternary (. node typeAnnotation) (lowerTypeExpr (. node typeAnnotation)) undefined)) (init (lowerExpr (. node init))))))
        (if (=== (. node tag) 'if')
          (return (object (tag 'if-stmt') (test (lowerExpr (. node test))) (ifthen (lowerStmt (. node ifthen))) (ifelse (ternary (. node ifelse) (lowerStmt (. node ifelse)) undefined)))))
        (if (=== (. node tag) 'while')
          (return (object (tag 'while-stmt') (test (lowerExpr (. node test))) (body ((. (. node body) map) lowerStmt)))))
        (if (=== (. node tag) 'block')
          (return (object (tag 'block-stmt') (body ((. (. node body) map) lowerStmt)))))
        (if (=== (. node tag) 'return')
          (return (object (tag 'return-stmt') (expr (ternary (. node expr) (lowerExpr (. node expr)) undefined)))))
        (if (=== (. node tag) 'assign')
          (return (object (tag 'assign-stmt') (name (. node name)) (value (lowerExpr (. node value))))))
        (if (=== (. node tag) 'throw')
          (return (object (tag 'throw-stmt') (expr (lowerExpr (. node expr))))))
        (if (=== (. node tag) 'import')
          (return (lowerImport node)))
        (if (=== (. node tag) 'switch')
          (return (lowerSwitch node)))
        (if (=== (. node tag) 'for')
          (return (object (tag 'for-stmt') (initName (. node initName)) (initExpr (lowerExpr (. node initExpr))) (test (lowerExpr (. node test))) (updateName (. node updateName)) (updateExpr (lowerExpr (. node updateExpr))) (body ((. (. node body) map) lowerStmt)))))
        (if (=== (. node tag) 'for-in')
          (return (object (tag 'for-in-stmt') (name (. node name)) ("object" (lowerExpr (. node "object"))) (body ((. (. node body) map) lowerStmt)))))
        (if (=== (. node tag) 'for-of')
          (return (object (tag 'for-of-stmt') (name (. node name)) (iterable (lowerExpr (. node iterable))) (body ((. (. node body) map) lowerStmt)))))
        (if (=== (. node tag) 'expr-stmt')
          (return (object (tag 'expr-stmt') (expr (lowerExpr (. node expr))))))
        (throw (new Error (+ 'lowerStmt: unexpected tag >' (. node tag) '<')))))
    (lowerLetStar
      (lambda ((node))
        (let* ((stmts (array)))
          ((. (. node bindings) forEach) (lambda ((b))
            ((. stmts push) (object (tag 'let-stmt') (name (. b name)) (typeAnnotation (ternary (. b typeAnnotation) (lowerTypeExpr (. b typeAnnotation)) undefined)) (init (cond (. b init) (lowerExpr (. b init)) :else undefined))))))
          ((. (. node body) forEach) (lambda ((s))
            ((. stmts push) (lowerStmt s))))
          (return (object (tag 'block-stmt') (body stmts))))))
    (lowerConstStar
      (lambda ((node))
        (let* ((stmts (array)))
          ((. (. node bindings) forEach) (lambda ((b))
            ((. stmts push) (object (tag 'const-stmt') (name (. b name)) (typeAnnotation (ternary (. b typeAnnotation) (lowerTypeExpr (. b typeAnnotation)) undefined)) (init (cond (. b init) (lowerExpr (. b init)) :else undefined))))))
          ((. (. node body) forEach) (lambda ((s))
            ((. stmts push) (lowerStmt s))))
          (return (object (tag 'block-stmt') (body stmts))))))
    (lowerImport
      (lambda ((node))
        (let* ((spec (. node spec))
               (defaultName undefined)
               (namespaceName undefined)
               (named undefined))
          (if spec
            ((. (. spec fields) forEach) (lambda ((f))
              (if (=== (. f key) ':default')
                (set! defaultName (. (. f value) value)))
              (if (=== (. f key) ':namespace')
                (set! namespaceName (. (. f value) value)))
              (if (=== (. f key) ':named')
                (set! named ((. (. (. f value) elements) map) (lambda ((el))
                  (let* ((nm undefined)
                         (al undefined))
                    ((. (. el fields) forEach) (lambda ((ff))
                      (if (=== (. ff key) ':name')
                        (set! nm (. (. ff value) value)))
                      (if (=== (. ff key) ':as')
                        (set! al (. (. ff value) value)))))
                    (return (object (name nm) ("alias" al)))))))))))
          (return (object (tag 'import-stmt') (defaultName defaultName) (namespaceName namespaceName) (named named) (source (. node source)))))))
    (lowerSwitch
      (lambda ((node))
        (let* ((discriminant (lowerExpr (. node discriminant)))
               (cases ((. (. node cases) map) (lambda ((c))
                 (return (object (test (lowerExpr (. c test))) (body ((. (. c body) map) lowerStmt)))))))
               (defaultCase (ternary (. node defaultCase) (object (body ((. (. (. node defaultCase) body) map) lowerStmt))) undefined)))
          (return (object (tag 'switch-stmt') (discriminant discriminant) (cases cases) (defaultCase defaultCase))))))
    (lowerExpr
      (lambda ((node))
        (if (=== (. node tag) 'prop-access')
          (return (object (tag 'prop-access-expr') ("object" (lowerExpr (. node "object"))) (key (. node key)))))
        (if (=== (. node tag) 'index-access')
          (return (object (tag 'index-access-expr') ("object" (lowerExpr (. node "object"))) ("index" (lowerExpr (. node "index"))))))
        (if (=== (. node tag) 'literal')
          (return node))
        (if (=== (. node tag) 'keyword')
          (return node))
        (if (=== (. node tag) 'identifier')
          (return node))
        (if (=== (. node tag) 'lambda')
          (return (object (tag 'lambda') (params (. node params)) (body ((. (. node body) map) lowerStmt)))))
        (if (=== (. node tag) 'object')
          (return (object (tag 'object-expr') (fields ((. (. node fields) map) (lambda ((f)) (return (object (key (. f key)) (value (lowerExpr (. f value)))))))))))
        (if (=== (. node tag) 'array')
          (return (object (tag 'array-expr') (elements ((. (. node elements) map) lowerExpr)))))
        (if (=== (. node tag) 'quasi')
          (return (object (tag 'quasi-expr') (expr (lowerExpr (. node expr))))))
        (if (=== (. node tag) 'unquote')
          (return (object (tag 'unquote-expr') (expr (lowerExpr (. node expr))))))
        (if (=== (. node tag) 'unquote-splicing')
          (return (object (tag 'unquote-splicing-expr') (expr (lowerExpr (. node expr))))))
        (if (=== (. node tag) 'ternary')
          (return (object (tag 'ternary-expr') (test (lowerExpr (. node test))) (ifthen (lowerExpr (. node ifthen))) (ifelse (lowerExpr (. node ifelse))))))
        (if (=== (. node tag) 'cond')
          (return (lowerCond node)))
        (if (=== (. node tag) 'new')
          (let* ((typeArgs (ternary ((. node typeArgs))
                                      ((. ((. node typeArgs) map) lowerTypeExpr))
                                      (array)))
                 (args ((. (. node args) map) lowerExpr)))
            (return (object (tag 'new-expr') (name (. node name)) (typeArgs typeArgs) (args args)))))
        (if (=== (. node tag) 'opt-chain')
          (return (object (tag 'opt-chain-expr') ("object" (lowerExpr (. node "object"))) (key (. node key)))))
        (if (=== (. node tag) 'null-coalesce')
          (return (object (tag 'null-coalesce-expr') (left (lowerExpr (. node left))) (right (lowerExpr (. node right))))))
        (if (=== (. node tag) 'call')
          (return (lowerCall node)))
        (throw (new Error (+ 'lowerExpr: unexpected tag >' (. node tag) '<')))))
    (lowerCall
      (lambda ((node))
        (if (&& (=== (. (. node fn) tag) 'identifier') (isOperator (. (. node fn) name)))
          (let* ((op (. (. node fn) name))
                 (args ((. (. node args) map) lowerExpr)))
            (if (=== (. args length) 1)
              (return (object (tag 'operator-expr') (op op) (args args))))
            (let* ((result (object (tag 'operator-expr') (op op) (args (array (index args 0) (index args 1)))))
                   (i 2))
              (while (< i (. args length))
                (set! result (object (tag 'operator-expr') (op op) (args (array result (index args i)))))
                (set! i (+ i 1)))
              (return result))))
        (let* ((typeArgs (ternary ((. node typeArgs))
                                   ((. ((. node typeArgs) map) lowerTypeExpr))
                                   (array)))
               (args ((. (. node args) map) lowerExpr)))
          (return (object (tag 'call') (fn (lowerExpr (. node fn))) (args args) (typeArgs typeArgs))))))
    (lowerCond
      (lambda ((node))
        (let* ((clauses (. node clauses))
               (i (- (. clauses length) 1))
               (last (index clauses i))
               (result (object (tag 'ternary-expr') (test (lowerExpr (. last test))) (ifthen (lowerExpr (. last expr))) (ifelse (object (tag 'literal') (value undefined))))))
          (set! i (- i 1))
          (while (>= i 0)
            (let* ((c (index clauses i)))
              (set! result (object (tag 'ternary-expr') (test (lowerExpr (. c test))) (ifthen (lowerExpr (. c expr))) (ifelse result))))
            (set! i (- i 1)))
          (return result))))
    ;; ========== Phase B: Type Expression Lowering ==========
    (lowerTypeExpr
      (lambda ((node))
        (if (=== (. node tag) 'type-id')
          (return node))
        (if (=== (. node tag) 'type-union')
          (return (object (tag 'type-union') (members ((. (. node members) map) lowerTypeExpr)))))
        (if (=== (. node tag) 'type-intersection')
          (return (object (tag 'type-intersection') (members ((. (. node members) map) lowerTypeExpr)))))
        (if (=== (. node tag) 'type-array')
          (return (object (tag 'type-array') (element (lowerTypeExpr (. node element))))))
        (if (=== (. node tag) 'type-app')
          (let* ((lowerCallee (lowerTypeExpr (. node callee)))
                 (reserved (array "union" "intersect" "array" "tuple" "fn" "obj" "tlit" "keyof" "typeof" "index" "cond" "infer" "mapped" "template" "rest" "readonly" "type-params" "type-args" "extends" "default" "modifiers")))
            ;; enforce that the callee of a positional type application is not a reserved keyword
            (if (&& (=== (. lowerCallee tag) 'type-id') ((. reserved includes) (. lowerCallee name)))
              (throw (new Error (+ 'Invalid type application: reserved keyword used as constructor: ' (. lowerCallee name)))))
            (return (object (tag 'type-app') (callee lowerCallee) (args ((. (. node args) map) lowerTypeExpr))))))
        (if (=== (. node tag) 'type-tuple')
          (return (object (tag 'type-tuple') (elements ((. (. node elements) map) (lambda ((el))
            (return (object (tag (. el tag)) (name (. el name)) ("type" (lowerTypeExpr (. el "type")))))))))))
        (if (=== (. node tag) 'type-fn')
          (return (object (tag 'type-fn')
            (typeParams ((. (. node typeParams) map) (lambda ((p))
              (return (object (name (. p name))
                (constraint (ternary (. p constraint) (lowerTypeExpr (. p constraint)) undefined))
                ("default" (ternary (. p "default") (lowerTypeExpr (. p "default")) undefined)))))))
            (params ((. (. node params) map) (lambda ((p))
              (return (object (name (. p name)) ("optional" (. p "optional")) ("type" (lowerTypeExpr (. p "type"))))))))
            (result (lowerTypeExpr (. node result))))))
        (if (=== (. node tag) 'type-obj')
          (return (object (tag 'type-obj') (props ((. (. node props) map) (lambda ((p))
            (return (object ("readonly" (. p "readonly")) (name (. p name)) ("optional" (. p "optional")) ("type" (lowerTypeExpr (. p "type")))))))))))
        (if (=== (. node tag) 'type-literal')
          (return node))
        (if (=== (. node tag) 'type-keyof')
          (return (object (tag 'type-keyof') (operand (lowerTypeExpr (. node operand))))))
        (if (=== (. node tag) 'type-typeof')
          (return node))
        (if (=== (. node tag) 'type-index')
          (return (object (tag 'type-index') ("object" (lowerTypeExpr (. node "object"))) ("index" (lowerTypeExpr (. node "index"))))))
        (if (=== (. node tag) 'type-cond')
          (return (object (tag 'type-cond') (subject (lowerTypeExpr (. node subject))) (constraint (lowerTypeExpr (. node constraint))) (trueBranch (lowerTypeExpr (. node trueBranch))) (falseBranch (lowerTypeExpr (. node falseBranch))))))
        (if (=== (. node tag) 'type-infer')
          (return node))
        (if (=== (. node tag) 'type-mapped')
          (return (object (tag 'type-mapped') (binding (. node binding)) (constraint (lowerTypeExpr (. node constraint))) (modifiers (. node modifiers)) (value (lowerTypeExpr (. node value))))))
        (if (=== (. node tag) 'type-template')
          (return (object (tag 'type-template') (parts ((. (. node parts) map) (lambda ((p))
            (if (=== (. p tag) 'str')
              (return p))
            (return (object (tag 'type') ("type" (lowerTypeExpr (. p "type")))))))))))
        (throw (new Error (+ 'lowerTypeExpr: unexpected tag >' (. node tag) '<')))))
    ;; ========== Phase C: Codegen ==========
    (emitProgram
      (lambda ((node))
        (return ((. ((. (. node body) map) emitTopLevel) join) '\n'))))
    (emitTopLevel
      (lambda ((node))
        (if (=== (. node tag) 'defmacro')
          (return (+ '// macro: ' (. node name))))
        (return (emitStmt node))))
    (emitStmt
      (lambda ((stmt))
        (if (=== (. stmt tag) 'let-stmt')
          (let* ((typeStr (ternary (. stmt typeAnnotation) (+ ': ' (emitTypeExpr (. stmt typeAnnotation))) ' ')))
            (if (isDefined (. stmt init))
              (return (+ 'let ' (. stmt name) typeStr ' = ' (emitExpr (. stmt init)) ';'))
              (return (+ 'let ' (. stmt name) typeStr ';')))))
        (if (=== (. stmt tag) 'const-stmt')
          (let* ((typeStr (ternary (. stmt typeAnnotation) (+ ': ' (emitTypeExpr (. stmt typeAnnotation))) ' ')))
            (if (isDefined (. stmt init))
              (return (+ 'const ' (. stmt name) typeStr ' = ' (emitExpr (. stmt init)) ';'))
              (return (+ 'const ' (. stmt name) typeStr ';')))))
        (if (=== (. stmt tag) 'if-stmt')
          (return (emitIf stmt)))
        (if (=== (. stmt tag) 'while-stmt')
          (return (emitWhile stmt)))
        (if (=== (. stmt tag) 'block-stmt')
          (return (emitBlock stmt)))
			  (if (=== (. stmt tag) 'assign-stmt')
				  (return (+ (. stmt name) " = " (emitExpr (. stmt value)) ';')))
        (if (=== (. stmt tag) 'return-stmt')
          (if (. stmt expr)
            (return (+ 'return ' (emitExpr (. stmt expr)) ';'))
            (return 'return;')))
        (if (=== (. stmt tag) 'throw-stmt')
          (return (+ 'throw ' (emitExpr (. stmt expr)) ';')))
        (if (=== (. stmt tag) 'import-stmt')
          (return (emitImport stmt)))
        (if (=== (. stmt tag) 'switch-stmt')
          (return (emitSwitch stmt)))
        (if (=== (. stmt tag) 'for-stmt')
          (return (emitFor stmt)))
        (if (=== (. stmt tag) 'for-in-stmt')
          (return (emitForIn stmt)))
        (if (=== (. stmt tag) 'for-of-stmt')
          (return (emitForOf stmt)))
        (if (=== (. stmt tag) 'expr-stmt')
          (return (+ (emitExpr (. stmt expr)) ';')))
        (throw (new Error (+ 'emitStmt: unexpected tag >' (. stmt tag) '<')))))
    (emitIf
      (lambda ((node))
        (let* ((lines (array)))
          ((. lines push) (+ 'if (' (emitExpr (. node test)) ') {'))
          ((. lines push) (indent (emitStmt (. node ifthen))))
          ((. lines push) '}')
          (if (isDefined (. node ifelse))
            (let* ()
              ((. lines push) 'else {')
              ((. lines push) (indent (emitStmt (. node ifelse))))
              ((. lines push) '}')))
          (return ((. lines join) '\n')))))
    (emitWhile
      (lambda ((node))
        (let* ((lines (array)))
          ((. lines push) (+ 'while (' (emitExpr (. node test)) ') {'))
          ((. (. node body) forEach) (lambda ((s))
            ((. lines push) (indent (emitStmt s)))))
          ((. lines push) '}')
          (return ((. lines join) '\n')))))
    (emitBlock
      (lambda ((node))
        (let* ((lines (array '{')))
          ((. (. node body) forEach) (lambda ((s))
            ((. lines push) (indent (emitStmt s)))))
          ((. lines push) '}')
          (return ((. lines join) '\n')))))
    (emitImport
      (lambda ((node))
        (let* ((parts (array)))
          (if (. node defaultName)
            ((. parts push) (. node defaultName)))
          (if (. node namespaceName)
            ((. parts push) (+ '* as ' (. node namespaceName))))
          (if (. node named)
            (let* ((specs ((. (. node named) map) (lambda ((n))
                     (if (. n "alias")
                       (return (+ (. n name) ' as ' (. n "alias")))
                       (return (. n name)))))))
              ((. parts push) (+ '{ ' ((. specs join) ', ') ' }'))))
          (if (> (. parts length) 0)
            (return (+ 'import ' ((. parts join) ', ') ' from ' ((. JSON stringify) (. node source)) ';')))
          (return (+ 'import ' ((. JSON stringify) (. node source)) ';')))))
    (emitSwitch
      (lambda ((node))
        (let* ((lines (array)))
          ((. lines push) (+ 'switch (' (emitExpr (. node discriminant)) ') {'))
          ((. (. node cases) forEach) (lambda ((c))
            ((. lines push) (+ '  case ' (emitExpr (. c test)) ':'))
            ((. (. c body) forEach) (lambda ((s))
              ((. lines push) (indent (indent (emitStmt s))))))
            ((. lines push) '    break;')))
          (if (. node defaultCase)
            (begin
              ((. lines push) '  default:')
              ((. (. (. node defaultCase) body) forEach) (lambda ((s))
                ((. lines push) (indent (indent (emitStmt s))))))))
          ((. lines push) '}')
          (return ((. lines join) '\n')))))
    (emitFor
      (lambda ((node))
        (let* ((lines (array))
               (init (+ 'let ' (. node initName) ' = ' (emitExpr (. node initExpr))))
               (test (emitExpr (. node test)))
               (update (+ (. node updateName) ' = ' (emitExpr (. node updateExpr)))))
          ((. lines push) (+ 'for (' init '; ' test '; ' update ') {'))
          ((. (. node body) forEach) (lambda ((s))
            ((. lines push) (indent (emitStmt s)))))
          ((. lines push) '}')
          (return ((. lines join) '\n')))))
    (emitForIn
      (lambda ((node))
        (let* ((lines (array)))
          ((. lines push) (+ 'for (const ' (. node name) ' in ' (emitExpr (. node "object")) ') {'))
          ((. (. node body) forEach) (lambda ((s))
            ((. lines push) (indent (emitStmt s)))))
          ((. lines push) '}')
          (return ((. lines join) '\n')))))
    (emitForOf
      (lambda ((node))
        (let* ((lines (array)))
          ((. lines push) (+ 'for (const ' (. node name) ' of ' (emitExpr (. node iterable)) ') {'))
          ((. (. node body) forEach) (lambda ((s))
            ((. lines push) (indent (emitStmt s)))))
          ((. lines push) '}')
          (return ((. lines join) '\n')))))
    (emitExpr
      (lambda ((expr))
        (if (=== (. expr tag) 'prop-access-expr')
          (return (+ (emitExpr (. expr "object")) '.' (. expr key))))
        (if (=== (. expr tag) 'index-access-expr')
          (return (+ (emitExpr (. expr "object")) '[' (emitExpr (. expr "index")) ']')))
        (if (=== (. expr tag) 'literal')
          (return ((. JSON stringify) (. expr value))))
        (if (=== (. expr tag) 'keyword')
          (return ((. JSON stringify) (. expr value))))
        (if (=== (. expr tag) 'identifier')
          (return (. expr name)))
        (if (=== (. expr tag) 'object-expr')
          (return (+ '({' ((. ((. (. expr fields) map) (lambda ((f)) (return (+ (. f key) ': ' (emitExpr (. f value)))))) join) ', ') '})')))
        (if (=== (. expr tag) 'array-expr')
          (return (+ '[' ((. ((. (. expr elements) map) emitExpr) join) ', ') ']')))
        (if (=== (. expr tag) 'quasi-expr')
          (return (+ '/* quasiquote */ ' (emitExpr (. expr expr)))))
        (if (=== (. expr tag) 'unquote-expr')
          (return (+ '/* unquote */ ' (emitExpr (. expr expr)))))
        (if (=== (. expr tag) 'unquote-splicing-expr')
          (return (+ '/* unquote-splicing */ ' (emitExpr (. expr expr)))))
        (if (=== (. expr tag) 'ternary-expr')
          (return (+ '(' (emitExpr (. expr test)) ' ? ' (emitExpr (. expr ifthen)) ' : ' (emitExpr (. expr ifelse)) ')')))
        (if (=== (. expr tag) 'call')
          (return (emitCall expr)))
        (if (=== (. expr tag) 'lambda')
          (return (emitLambda expr)))
        (if (=== (. expr tag) 'new-expr')
          (let* ((tstr (ternary (&& ((. expr typeArgs)) (> ((. ((. expr typeArgs) length))) 0))
                      (+ '<' ((. ((. expr typeArgs) map) emitTypeExpr) join) ', ' '>')
                      ''))
                 (argsStr ((. ((. (. expr args) map) emitExpr) join) ', ')))
            (return (+ 'new ' (. expr name) tstr '(' argsStr ')'))))
        (if (=== (. expr tag) 'opt-chain-expr')
          (return (+ (emitExpr (. expr "object")) '?.' (. expr key))))
        (if (=== (. expr tag) 'null-coalesce-expr')
          (return (+ '(' (emitExpr (. expr left)) ' ?? ' (emitExpr (. expr right)) ')')))
        (if (=== (. expr tag) 'operator-expr')
          (return (emitOperator expr)))
        (throw (new Error (+ 'emitExpr: unexpected tag >' (. expr tag) '<')))))
    (emitLambda
      (lambda ((node))
        (let* ((params ((. (. node params) join) ', '))
               (body ((. (. node body) map) emitStmt)))
          (return (+ '(' params ') => {\n' (indent ((. body join) '\n')) '\n}')))))
    (emitCall
      (lambda ((node))
        (let* ((fn (emitExpr (. node fn)))
               (typeStr (if (&& ((. node typeArgs)) (> ((. (. node typeArgs) length)) 0))
                           (+ '<' ((. ((. node typeArgs) map) emitTypeExpr) join) ', ' '>' )
                           ''))
               (args ((. (. node args) map) emitExpr)))
          (if (=== (. (. node fn) tag) 'lambda')
            (return (+ '(' fn ')' typeStr '(' ((. args join) ', ') ')')))
          (return (+ fn typeStr '(' ((. args join) ', ') ')')))))
    (emitOperator
      (lambda ((node))
        (let* ((args ((. (. node args) map) emitExpr)))
          (if (=== (. args length) 1)
            (return (+ '(' (. node op) (index args 0) ')')))
          (return (+ '(' (index args 0) ' ' (. node op) ' ' (index args 1) ')')))))
    ;; ========== Phase C: Type Expression Codegen ==========
    (typePrecedence
      (lambda ((tag))
        (if (=== tag 'type-cond') (return 1))
        (if (=== tag 'type-union') (return 2))
        (if (=== tag 'type-intersection') (return 3))
        (if (=== tag 'type-keyof') (return 4))
        (if (=== tag 'type-typeof') (return 4))
        (if (=== tag 'type-infer') (return 4))
        (if (=== tag 'type-array') (return 4))
        (if (=== tag 'type-index') (return 5))
        (return 6)))
    (typeWrapIf
      (lambda ((node) (contextPrec))
        (let* ((s (emitTypeExpr node))
               (innerPrec (typePrecedence (. node tag))))
          (if (< innerPrec contextPrec)
            (return (+ '(' s ')')))
          (return s))))
    (emitTypeExpr
      (lambda ((node))
        (if (=== (. node tag) 'type-id')
          (return (. node name)))
        (if (=== (. node tag) 'type-app')
          (let* ((callee (emitTypeExpr (. node callee)))
                 (args ((. ((. (. node args) map) emitTypeExpr) join) ', ')))
            (return (+ callee '<' args '>'))))
        (if (=== (. node tag) 'type-union')
          (return ((. ((. (. node members) map) (lambda ((m)) (return (typeWrapIf m 2)))) join) ' | ')))
        (if (=== (. node tag) 'type-intersection')
          (return ((. ((. (. node members) map) (lambda ((m)) (return (typeWrapIf m 3)))) join) ' & ')))
        (if (=== (. node tag) 'type-array')
          (let* ((inner (emitTypeExpr (. node element)))
                 (needsWrap (< (typePrecedence (. (. node element) tag)) 4)))
            (if needsWrap
              (return (+ '(' inner ')[]')))
            (return (+ inner '[]'))))
        (if (=== (. node tag) 'type-tuple')
          (let* ((parts ((. ((. (. node elements) map) emitTupleElement) join) ', ')))
            (return (+ '[' parts ']'))))
        (if (=== (. node tag) 'type-fn')
          (return (emitFnType node)))
        (if (=== (. node tag) 'type-obj')
          (return (emitObjType node)))
        (if (=== (. node tag) 'type-literal')
          (return (emitTypeLiteral node)))
        (if (=== (. node tag) 'type-keyof')
          (return (+ 'keyof ' (typeWrapIf (. node operand) 4))))
        (if (=== (. node tag) 'type-typeof')
          (return (+ 'typeof ' (. node name))))
        (if (=== (. node tag) 'type-index')
          (return (+ (emitTypeExpr (. node "object")) '[' (emitTypeExpr (. node "index")) ']')))
        (if (=== (. node tag) 'type-cond')
          (return (+ (emitTypeExpr (. node subject)) ' extends ' (emitTypeExpr (. node constraint)) ' ? ' (emitTypeExpr (. node trueBranch)) ' : ' (emitTypeExpr (. node falseBranch)))))
        (if (=== (. node tag) 'type-infer')
          (return (+ 'infer ' (. node name))))
        (if (=== (. node tag) 'type-mapped')
          (return (emitMappedType node)))
        (if (=== (. node tag) 'type-template')
          (return (emitTemplateType node)))
        (throw (new Error (+ 'emitTypeExpr: unexpected tag >' (. node tag) '<')))))
    (emitTupleElement
      (lambda ((el))
        (if (=== (. el tag) 'element')
          (return (emitTypeExpr (. el "type"))))
        (if (=== (. el tag) 'rest')
          (return (+ '...' (emitTypeExpr (. el "type")))))
        (if (=== (. el tag) 'labeled')
          (return (+ (. el name) ': ' (emitTypeExpr (. el "type")))))
        (throw (new Error 'Unknown tuple element'))))
    (emitFnType
      (lambda ((node))
        (let* ((tparams (ternary (&& (. node typeParams) (> (. (. node typeParams) length) 0))
                 (+ '<' ((. ((. (. node typeParams) map) emitTypeParamDecl) join) ', ') '>') ' '))
               (params ((. ((. (. node params) map) (lambda ((p))
                 (let* ((opt (ternary (. p "optional") '?' ' '))
                        (ty (emitTypeExpr (. p "type"))))
                   (return (+ (. p name) opt ': ' ty))))) join) ', '))
               (ret (emitTypeExpr (. node result))))
          (return (+ tparams '(' params ') => ' ret)))))
    (emitObjType
      (lambda ((node))
        (if (=== (. (. node props) length) 0)
          (return '{}'))
        (let* ((props ((. ((. (. node props) map) (lambda ((p))
                 (let* ((ro (ternary (. p "readonly") 'readonly ' ' '))
                        (opt (ternary (. p "optional") '?' ' '))
                        (ty (emitTypeExpr (. p "type"))))
                   (return (+ ro (. p name) opt ': ' ty))))) join) '; ')))
          (return (+ '{ ' props ' }')))))
    (emitTypeLiteral
      (lambda ((node))
        (if (=== (typeof (. node value)) 'string')
          (return ((. JSON stringify) (. node value))))
        (return (String (. node value)))))
    (emitMappedType
      (lambda ((node))
        (let* ((constraint (emitTypeExpr (. node constraint)))
               (value (emitTypeExpr (. node value)))
               (modStr ' ')
               (optSuffix ' '))
          (if (. node modifiers)
            ((. (. node modifiers) forEach) (lambda ((m))
              (if (|| (=== m 'readonly') (|| (=== m '+readonly') (=== m '-readonly')))
                (set! modStr (+ m ' ')))
              (if (|| (=== m '?') (|| (=== m '+?') (=== m '-?')))
                (set! optSuffix m)))))
          (return (+ '{ ' modStr '[' (. node binding) ' in ' constraint ']' optSuffix ': ' value ' }')))))
    (emitTemplateType
      (lambda ((node))
        (let* ((out '`'))
          ((. (. node parts) forEach) (lambda ((part))
            (if (=== (. part tag) 'str')
              (set! out (+ out (. part value)))
              (set! out (+ out '${' (emitTypeExpr (. part "type")) '}')))))
          (set! out (+ out '`'))
          (return out))))
    (emitTypeParamDecl
      (lambda ((p))
        (let* ((out (. p name)))
          (if (. p constraint)
            (set! out (+ out ' extends ' (emitTypeExpr (. p constraint)))))
          (if (. p "default")
            (set! out (+ out ' = ' (emitTypeExpr (. p "default")))))
          (return out))))
    ;; ========== main ==========
    (main
      (lambda ()
        (let* ((input ((. fs readFileSync) (index (. process argv) 2) 'utf-8'))
               (inputStream ((. CharStream fromString) input))
               (lexer (new Stage3DLexer inputStream))
               (tokenStream (new CommonTokenStream lexer))
               (parser (new Stage3DParser tokenStream))
               (tree ((. parser "program")))
               ;; Phase A: CST â†’ surface AST
               (surfaceAst (astProgram tree))
               ;; Phase B: lowering â†’ canonical AST
               (canonicalAst (lowerProgram surfaceAst)))
          ;; Phase C: codegen â†’ TypeScript
          ((. console log) (emitProgram canonicalAst)))))
    ;; end of let*
   )
   (main)
  )
)