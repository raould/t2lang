(program
  (raw """import { CharStream, CommonTokenStream } from 'antlr4ng';
          import { Stage3BLexer } from './Stage3BLexer';
          import { BindingContext, ParamContext, Stage3BParser } from './Stage3BParser';
          import fs from 'node:fs';""")
  (let* (
    ;; ========== helpers ==========
    (dbg (lambda ((...msgs)) (raw """console.error(...msgs);""")))
    (lg (lambda ((name) (lam))
      (return (lambda ((...args))
        ;; (console.log "+ entering" name)
        (let* ((rez ((. lam apply) this args)))
          ;; (console.log "- returning" name rez)
          (return rez)
        ))
    )))
    (parseString
      (lambda ((tokenText))
        (let* ((raw_ tokenText))
          (if (raw_.startsWith '"""')
            (raw """return raw_.slice(3, -3)"""))
          (let* ((inner (raw_.slice 1 -1)))
            (raw """return JSON.parse('"' + inner.replace(/"/g, '\\"') + '"')""")))))
    (indent
      (lambda ((text))
        (raw """return text.split('\n').map(line => '  ' + line).join('\n')""")))
    (isDefined
      (lambda ((val))
        (raw """return val !== undefined""")))
    (isOperator
      (lambda ((name))
        (raw """return ["<", ">", "<=", ">=", "&&", "||", "!=", "!==", "==", "===",
                  "+", "-", "*", "/", "%", "^", "!"].includes(name)""")))
    ;; ========== Phase A: CST → Surface AST ==========
    (astProgram
      (lambda ((ctx))
        (let* ((body (raw """ctx.topLevel().map(astTopLevel)""")))
          (raw """return { tag: 'program', body }"""))))
    (astTopLevel
      (lambda ((ctx))
        (if (ctx.defmacro)
          (raw """return astDefmacro(ctx.defmacro())"""))
        (if (ctx.def)
          (raw """return astDef(ctx.def())"""))
        (raw """return astStatement(ctx.statement())""")))
    (astDefmacro
      (lambda ((ctx))
        (let* ((name (raw """ctx.IDENTIFIER().getText()"""))
               (params (raw """ctx.fnSignature().param().map((p: ParamContext) => p.IDENTIFIER().getText())"""))
               (body (raw """ctx.statement().map(astStatement)""")))
          (raw """return { tag: 'defmacro', name, params, body }"""))))
    (astDef
      (lambda ((ctx))
        (let* ((name (raw """ctx.IDENTIFIER().getText()"""))
               (init (astExpression (ctx.expression))))
          (raw """return { tag: 'def', name, init }"""))))
    (astStatement
      (lg "astStatement" (lambda ((ctx))
        (if (ctx.letStar)
          (raw """return astLetStar(ctx.letStar())"""))
        (if (ctx.letStmt)
          (raw """return astLetStmt(ctx.letStmt())"""))
        (if (ctx.ifForm)
          (raw """return astIf(ctx.ifForm())"""))
        (if (ctx.whileForm)
          (raw """return astWhile(ctx.whileForm())"""))
        (if (ctx.block)
          (raw """return astBlock(ctx.block())"""))
        (if (ctx.returnForm)
          (raw """return astReturn(ctx.returnForm())"""))
        (if (ctx.throwForm)
          (raw """return astThrow(ctx.throwForm())"""))
        (if (ctx.importForm)
          (raw """return astImport(ctx.importForm())"""))
        (let* ((expr (astExpression (ctx.expression))))
          (raw """return { tag: 'expr-stmt', expr }""")))))
    (astThrow
      (lambda ((ctx))
        (let* ((expr (astExpression (ctx.expression))))
          (raw """return { tag: 'throw', expr }"""))))
    (astImport
      (lambda ((ctx))
        (let* ((spec (raw """ctx.objectExpr() ? astObjectExpr(ctx.objectExpr()) : undefined"""))
               (source (raw """parseString(ctx.STRING().getText())""")))
          (raw """return { tag: 'import', spec, source }"""))))
    (astLetStar
      (lambda ((ctx))
        (let* ((bindings (raw """ctx.binding().map((b: BindingContext) => {
          const id = b.IDENTIFIER().getText();
          const init = b.expression() ? astExpression(b.expression()) : undefined;
          return { name: id, init };
        })"""))
          (body (raw """ctx.statement().map(astStatement)""")))
          (raw """return { tag: 'let*', bindings, body }"""))))
    (astLetStmt
      (lambda ((ctx))
        (let* ((name (raw """ctx.IDENTIFIER().getText()"""))
               (init (astExpression (ctx.expression))))
          (raw """return { tag: 'let', name, init }"""))))
    (astIf
      (lambda ((ctx))
        (let* ((test (astExpression (ctx.expression)))
               (ifthen (astStatement (ctx.statement 0)))
               (ctxElse (ctx.statement 1))
               (ifelse (raw """ctxElse != undefined ? astStatement(ctxElse) : undefined""")))
          (raw """return { tag: 'if', test, ifthen, ifelse }"""))))
    (astWhile
      (lambda ((ctx))
        (let* ((test (astExpression (ctx.expression)))
               (body (raw """ctx.statement().map(astStatement)""")))
          (raw """return { tag: 'while', test, body }"""))))
    (astBlock
      (lambda ((ctx))
        (let* ((body (raw """ctx.statement().map(astStatement)""")))
          (raw """return { tag: 'block', body }"""))))
    (astReturn
      (lambda ((ctx))
        (let* ((expr (raw """ctx.expression() ? astExpression(ctx.expression()) : undefined""")))
          (raw """return { tag: 'return', expr }"""))))
    ;; Stage 3 additions
    (astObjectExpr
      (lambda ((ctx))
        (let* ((fields (raw """ctx.objectField().map(f => {
          let key;
          if (f.IDENTIFIER()) { key = f.IDENTIFIER().getText(); }
          else if (f.KEYWORD()) { key = f.KEYWORD().getText(); }
          else { key = parseString(f.STRING().getText()); }
          const value = astExpression(f.expression());
          return { key, value };
        })""")))
          (raw """return { tag: 'object', fields }"""))))
    (astArrayExpr
      (lambda ((ctx))
        (let* ((elements (raw """ctx.expression().map(astExpression)""")))
          (raw """return { tag: 'array', elements }"""))))
    (astQuasiquote
      (lambda ((ctx))
        (let* ((expr (astExpression (ctx.expression))))
          (raw """return { tag: 'quasi', expr }"""))))
    (astUnquote
      (lambda ((ctx))
        (let* ((expr (astExpression (ctx.expression))))
          (raw """return { tag: 'unquote', expr }"""))))
    (astUnquoteSplicing
      (lambda ((ctx))
        (let* ((expr (astExpression (ctx.expression))))
          (raw """return { tag: 'unquote-splicing', expr }"""))))
    (astTernary
      (lambda ((ctx))
        (let* ((test (astExpression (ctx.expression 0)))
               (ifthen (astExpression (ctx.expression 1)))
               (ifelse (astExpression (ctx.expression 2))))
          (raw """return { tag: 'ternary', test, ifthen, ifelse }"""))))
    (astCondExpr
      (lambda ((ctx))
        (let* ((exprs (raw """ctx.expression().map(astExpression)"""))
               (clauses (raw """[]"""))
               (i 0))
          (while (< i exprs.length)
            (raw """clauses.push({ test: exprs[i], expr: exprs[i + 1] })""")
            (raw """i += 2"""))
          (raw """return { tag: 'cond', clauses }"""))))
    (astNewExpr
      (lambda ((ctx))
        (let* ((clazz (raw """ctx.IDENTIFIER().getText()""")))
          (raw """return { tag: 'new', clazz, args: ctx.expression().map(e => astExpression(e)) }"""))))
    (astOptChain
      (lambda ((ctx))
        (let* ((obj (astExpression (ctx.expression)))
               (prop (raw """ctx.IDENTIFIER().getText()""")))
          (raw """return { tag: 'opt-chain', object: obj, key: prop }"""))))
    (astNullCoalesce
      (lambda ((ctx))
        (let* ((left (astExpression (ctx.expression 0)))
               (right (astExpression (ctx.expression 1))))
          (raw """return { tag: 'null-coalesce', left, right }"""))))
    (astExpression
      (lg "astExpression" (lambda ((ctx))
        (if (== ctx undefined)
          (raw """console.error('astExpression: ctx is undefined or null'); return { tag: 'error', reason: 'ctx undefined' }"""))
        (if (ctx.literal)
          (raw """return astLiteral(ctx.literal())"""))
        (if (ctx.KEYWORD)
          (raw """return { tag: 'keyword', value: ctx.KEYWORD().getText() }"""))
        (if (ctx.IDENTIFIER)
          (raw """
          const text = ctx.IDENTIFIER().getText();
          if (text.includes('.')) {
            throw new Error("Invalid use of dotted identifier: " + text + ". Use (. obj prop) syntax instead.");
          }
          return { tag: 'identifier', name: text }
          """))
        (if (ctx.lambda)
          (raw """return astLambda(ctx.lambda())"""))
        (if (ctx.assign)
          (raw """return astAssign(ctx.assign())"""))
        (if (ctx.objectExpr)
          (raw """return astObjectExpr(ctx.objectExpr())"""))
        (if (ctx.arrayExpr)
          (raw """return astArrayExpr(ctx.arrayExpr())"""))
        (if (ctx.propAccess)
          (raw """return astPropAccess(ctx.propAccess())"""))
        (if (ctx.indexAccess)
          (raw """return astIndexAccess(ctx.indexAccess())"""))
        (if (ctx.quasiquote)
          (raw """return astQuasiquote(ctx.quasiquote())"""))
        (if (ctx.unquote)
          (raw """return astUnquote(ctx.unquote())"""))
        (if (ctx.unquoteSplicing)
          (raw """return astUnquoteSplicing(ctx.unquoteSplicing())"""))
        (if (ctx.ternary)
          (raw """return astTernary(ctx.ternary())"""))
        (if (ctx.condExpr)
          (raw """return astCondExpr(ctx.condExpr())"""))
        (if (ctx.newForm)
          (raw """return astNewExpr(ctx.newForm())"""))
        (if (ctx.optChain)
          (raw """return astOptChain(ctx.optChain())"""))
        (if (ctx.nullCoalesce)
          (raw """return astNullCoalesce(ctx.nullCoalesce())"""))
        (if (ctx.call)
          (raw """return astCall(ctx.call())"""))
        (raw """throw new Error('Unknown expression: ' + (ctx.getText ? ctx.getText() : ctx))"""))))
    (astPropAccess
      (lambda ((ctx))
        (let* ((obj (astExpression (ctx.expression)))
               (key))
          (if (ctx.IDENTIFIER)
            (set! key (raw """ctx.IDENTIFIER().getText()""")))
          (if (ctx.KEYWORD)
            (set! key (raw """ctx.KEYWORD().getText()""")))
          (if (ctx.STRING)
            (set! key (raw """parseString(ctx.STRING().getText())""")))
          (raw """return { tag: 'prop-access', object: obj, key }"""))))
    (astIndexAccess
      (lambda ((ctx))
        (let* ((obj (astExpression (ctx.expression 0)))
               (idx (astExpression (ctx.expression 1))))
          (raw """return { tag: 'index-access', object: obj, index: idx }"""))))
    (astLambda
      (lambda ((ctx))
        (let* ((params (raw """ctx.fnSignature().param().map((p: ParamContext) => p.IDENTIFIER().getText())"""))
               (body (raw """ctx.statement().map(astStatement)""")))
          (raw """return { tag: 'lambda', params, body }"""))))
    (astAssign
      (lambda ((ctx))
        (let* ((name (raw """ctx.IDENTIFIER().getText()"""))
               (value (astExpression (ctx.expression))))
          (raw """return { tag: 'assign', name, value }"""))))
    (astCall
      (lambda ((ctx))
        (let* ((exprs (raw """ctx.expression().map(astExpression)""")))
          (raw """return { tag: 'call', fn: exprs[0], args: exprs.slice(1) }"""))))
    (astLiteral
      (lambda ((ctx))
        (if (ctx.NUMBER)
          (raw """return { tag: 'literal', value: Number(ctx.NUMBER().getText()) }"""))
        (if (ctx.STRING)
          (raw """return { tag: 'literal', value: parseString(ctx.STRING().getText()) }"""))
        (if (ctx.BOOLEAN)
          (raw """return { tag: 'literal', value: ctx.BOOLEAN().getText() === 'true' }"""))
        (if (ctx.NULL)
          (raw """return { tag: 'literal', value: null }"""))
        (if (ctx.UNDEFINED)
          (raw """return { tag: 'literal', value: undefined }"""))
        (raw """throw new Error('Unknown literal')""")))
    ;; ========== Phase B: Lowering ==========
    (lowerProgram
      (lambda ((node))
        (let* ((body (node.body.map lowerTopLevel)))
          (raw """return { tag: 'program', body }"""))))
    (lowerTopLevel
      (lambda ((node))
        (if (=== node.tag 'defmacro')
          (raw """return lowerDefmacro(node)"""))
        (if (=== node.tag 'def')
          (raw """return lowerDef(node)"""))
        (raw """return lowerStmt(node)""")))
    (lowerDefmacro
      (lambda ((node))
        (let* ((body (node.body.map lowerStmt)))
          (raw """return { tag: 'defmacro', name: node.name, params: node.params, body }"""))))
    (lowerDef
      (lambda ((node))
        (let* ((init (lowerExpr node.init)))
          (raw """return { tag: 'let-stmt', name: node.name, init }"""))))
    (lowerStmt
      (lg "lowerStmt" (lambda ((node))
        (if (=== node.tag 'let*')
          (raw """return lowerLetStar(node)"""))
        (if (=== node.tag 'let')
          (raw """return { tag: 'let-stmt', name: node.name, init: lowerExpr(node.init) }"""))
        (if (=== node.tag 'if')
          (raw """return { tag: 'if-stmt', test: lowerExpr(node.test), ifthen: lowerStmt(node.ifthen), ifelse: node.ifelse ? lowerStmt(node.ifelse) : undefined }"""))
        (if (=== node.tag 'while')
          (raw """return { tag: 'while-stmt', test: lowerExpr(node.test), body: node.body.map(lowerStmt) }"""))
        (if (=== node.tag 'block')
          (raw """return { tag: 'block-stmt', body: node.body.map(lowerStmt) }"""))
        (if (=== node.tag 'return')
          (raw """return { tag: 'return-stmt', expr: node.expr ? lowerExpr(node.expr) : undefined }"""))
        (if (=== node.tag 'throw')
          (raw """return { tag: 'throw-stmt', expr: lowerExpr(node.expr) }"""))
        (if (=== node.tag 'import')
          (raw """return lowerImport(node)"""))
        (if (=== node.tag 'expr-stmt')
          (raw """return { tag: 'expr-stmt', expr: lowerExpr(node.expr) }"""))
        (raw """throw new Error('lowerStmt: unexpected tag ' + node.tag)"""))))
    (lowerLetStar
      (lambda ((node))
        (let* ((stmts (raw """[]""")))
          (node.bindings.forEach (lambda ((b))
            (raw """stmts.push({ tag: 'let-stmt', name: b.name, init: b.init ? lowerExpr(b.init) : undefined })""")))
          (node.body.forEach (lambda ((s))
            (stmts.push (lowerStmt s))))
          (raw """return { tag: 'block-stmt', body: stmts }"""))))
    (lowerImport
      (lambda ((node))
        (raw """
          const spec = node.spec;
          let defaultName, namespaceName, named;
          if (spec) {
            for (const f of spec.fields) {
              if (f.key === ':default') defaultName = f.value.value;
              else if (f.key === ':namespace') namespaceName = f.value.value;
              else if (f.key === ':named') {
                named = f.value.elements.map(el => {
                  let name, alias;
                  for (const ff of el.fields) {
                    if (ff.key === ':name') name = ff.value.value;
                    else if (ff.key === ':as') alias = ff.value.value;
                  }
                  return { name, alias };
                });
              }
            }
          }
          return { tag: 'import-stmt', defaultName, namespaceName, named, source: node.source };
        """)))
    (lowerExpr
      (lg "lowerExpr" (lambda ((node))
        (if (=== node.tag 'prop-access')
          (raw """return { tag: 'prop-access-expr', object: lowerExpr(node.object), key: node.key }"""))
        (if (=== node.tag 'index-access')
          (raw """return { tag: 'index-access-expr', object: lowerExpr(node.object), index: lowerExpr(node.index) }"""))
        (if (=== node.tag 'literal')
          (raw """return node"""))
        (if (=== node.tag 'keyword')
          (raw """return node"""))
        (if (=== node.tag 'identifier')
          (raw """return node"""))
        (if (=== node.tag 'lambda')
          (raw """return { tag: 'lambda', params: node.params, body: node.body.map(lowerStmt) }"""))
        (if (=== node.tag 'assign')
          (raw """return { tag: 'assign-expr', name: node.name, value: lowerExpr(node.value) }"""))
        (if (=== node.tag 'object')
          (raw """return { tag: 'object-expr', fields: node.fields.map(f => ({ key: f.key, value: lowerExpr(f.value) })) }"""))
        (if (=== node.tag 'array')
          (raw """return { tag: 'array-expr', elements: node.elements.map(lowerExpr) }"""))
        (if (=== node.tag 'quasi')
          (raw """return { tag: 'quasi-expr', expr: lowerExpr(node.expr) }"""))
        (if (=== node.tag 'unquote')
          (raw """return { tag: 'unquote-expr', expr: lowerExpr(node.expr) }"""))
        (if (=== node.tag 'unquote-splicing')
          (raw """return { tag: 'unquote-splicing-expr', expr: lowerExpr(node.expr) }"""))
        (if (=== node.tag 'ternary')
          (raw """return { tag: 'ternary-expr', test: lowerExpr(node.test), ifthen: lowerExpr(node.ifthen), ifelse: lowerExpr(node.ifelse) }"""))
        (if (=== node.tag 'cond')
          (raw """return lowerCond(node)"""))
        (if (=== node.tag 'new')
          (raw """return { tag: 'new-expr', clazz: node.clazz, args: node.args.map(lowerExpr) }"""))
        (if (=== node.tag 'opt-chain')
          (raw """return { tag: 'opt-chain-expr', object: lowerExpr(node.object), key: node.key }"""))
        (if (=== node.tag 'null-coalesce')
          (raw """return { tag: 'null-coalesce-expr', left: lowerExpr(node.left), right: lowerExpr(node.right) }"""))
        (if (=== node.tag 'call')
          (raw """return lowerCall(node)"""))
        (raw """throw new Error('lowerExpr: unexpected tag ' + node.tag)"""))))
    (lowerCall
      (lambda ((node))
        (if (raw """node.fn.tag === 'identifier' && isOperator(node.fn.name)""")
          (let* ((op node.fn.name)
                 (args (node.args.map lowerExpr)))
            (if (=== args.length 1)
              (raw """return { tag: 'operator-expr', op, args }"""))
            (let* ((result (raw """{ tag: 'operator-expr', op, args: [args[0], args[1]] }"""))
                   (i 2))
              (while (< i args.length)
                (set! result (raw """{ tag: 'operator-expr', op, args: [result, args[i]] }"""))
                (raw """i++"""))
              (raw """return result"""))))
        (raw """return { tag: 'call', fn: lowerExpr(node.fn), args: node.args.map(lowerExpr) }""")))
    (lowerCond
      (lambda ((node))
        (let* ((clauses node.clauses)
               (i (- clauses.length 1))
               (last (index clauses i))
               (result (raw """{ tag: 'ternary-expr', test: lowerExpr(last.test), ifthen: lowerExpr(last.expr), ifelse: { tag: 'literal', value: undefined } }""")))
          (raw """i--""")
          (while (>= i 0)
            (let* ((c (index clauses i)))
              (set! result (raw """{ tag: 'ternary-expr', test: lowerExpr(c.test), ifthen: lowerExpr(c.expr), ifelse: result }""")))
            (raw """i--"""))
          (raw """return result"""))))
    ;; ========== Phase C: Codegen ==========
    (emitProgram
      (lambda ((node))
        (raw """return node.body.map(emitTopLevel).join('\n')""")))
    (emitTopLevel
      (lambda ((node))
        (if (=== node.tag 'defmacro')
          (raw """return '// macro: ' + node.name"""))
        (raw """return emitStmt(node)""")))
    (emitStmt
      (lg "emitStmt" (lambda ((stmt))
        (if (=== stmt.tag 'let-stmt')
          (if (isDefined stmt.init)
            (raw """return 'let ' + stmt.name + ' = ' + emitExpr(stmt.init) + ';'""")
            (raw """return 'let ' + stmt.name + ';'""")))
        (if (=== stmt.tag 'if-stmt')
          (raw """return emitIf(stmt)"""))
        (if (=== stmt.tag 'while-stmt')
          (raw """return emitWhile(stmt)"""))
        (if (=== stmt.tag 'block-stmt')
          (raw """return emitBlock(stmt)"""))
        (if (=== stmt.tag 'return-stmt')
          (if stmt.expr
            (raw """return 'return ' + emitExpr(stmt.expr) + ';'""")
            (raw """return 'return;'""")))
        (if (=== stmt.tag 'throw-stmt')
          (raw """return 'throw ' + emitExpr(stmt.expr) + ';'"""))
        (if (=== stmt.tag 'import-stmt')
          (raw """return emitImport(stmt)"""))
        (if (=== stmt.tag 'expr-stmt')
          (raw """return emitExpr(stmt.expr) + ';'"""))
        (raw """throw new Error('emitStmt: unexpected tag ' + stmt.tag)"""))))
    (emitIf
      (lambda ((node))
        (let* ((lines (raw """[]""")))
          (lines.push (+ 'if (' (emitExpr node.test) ') {'))
          (lines.push (indent (emitStmt node.ifthen)))
          (lines.push '}')
          (if (isDefined node.ifelse)
            (let* ()
              (lines.push 'else {')
              (lines.push (indent (emitStmt node.ifelse)))
              (lines.push '}')))
          (raw """return lines.join('\n')"""))))
    (emitWhile
      (lambda ((node))
        (let* ((lines (raw """[]""")))
          (lines.push (+ 'while (' (emitExpr node.test) ') {'))
          (node.body.forEach (lambda ((s))
            (lines.push (indent (emitStmt s)))))
          (lines.push '}')
          (raw """return lines.join('\n')"""))))
    (emitBlock
      (lambda ((node))
        (let* ((lines (raw """['{']""")))
          (node.body.forEach (lambda ((s))
            (lines.push (indent (emitStmt s)))))
          (lines.push '}')
          (raw """return lines.join('\n')"""))))
    (emitImport
      (lambda ((node))
        (raw """
          const parts = [];
          if (node.defaultName) parts.push(node.defaultName);
          if (node.namespaceName) parts.push('* as ' + node.namespaceName);
          if (node.named) {
            const specs = node.named.map(n => n.alias ? n.name + ' as ' + n.alias : n.name);
            parts.push('{ ' + specs.join(', ') + ' }');
          }
          if (parts.length > 0) {
            return 'import ' + parts.join(', ') + ' from ' + JSON.stringify(node.source) + ';';
          }
          return 'import ' + JSON.stringify(node.source) + ';';
        """)))
    (emitExpr
      (lg "emitExpr" (lambda ((expr))
        (if (=== expr.tag 'prop-access-expr')
          (raw """return emitExpr(expr.object) + '.' + expr.key"""))
        (if (=== expr.tag 'index-access-expr')
          (raw """return emitExpr(expr.object) + '[' + emitExpr(expr.index) + ']'"""))
        (if (=== expr.tag 'literal')
          (raw """return JSON.stringify(expr.value)"""))
        (if (=== expr.tag 'keyword')
          (raw """return JSON.stringify(expr.value)"""))
        (if (=== expr.tag 'identifier')
          (raw """return expr.name"""))
        (if (=== expr.tag 'object-expr')
          (raw """return '({' + expr.fields.map(f => f.key + ': ' + emitExpr(f.value)).join(', ') + '})'"""))
        (if (=== expr.tag 'array-expr')
          (raw """return '[' + expr.elements.map(emitExpr).join(', ') + ']'"""))
        (if (=== expr.tag 'quasi-expr')
          (raw """return '/* quasiquote */ ' + emitExpr(expr.expr)"""))
        (if (=== expr.tag 'unquote-expr')
          (raw """return '/* unquote */ ' + emitExpr(expr.expr)"""))
        (if (=== expr.tag 'unquote-splicing-expr')
          (raw """return '/* unquote-splicing */ ' + emitExpr(expr.expr)"""))
        (if (=== expr.tag 'ternary-expr')
          (raw """return '(' + emitExpr(expr.test) + ' ? ' + emitExpr(expr.ifthen) + ' : ' + emitExpr(expr.ifelse) + ')'"""))
        (if (=== expr.tag 'call')
          (raw """return emitCall(expr)"""))
        (if (=== expr.tag 'lambda')
          (raw """return emitLambda(expr)"""))
        (if (=== expr.tag 'assign-expr')
          (raw """return '(' + expr.name + ' = ' + emitExpr(expr.value) + ')'"""))
        (if (=== expr.tag 'new-expr')
          (raw """return emitNew(expr)"""))
        (if (=== expr.tag 'opt-chain-expr')
          (raw """return emitExpr(expr.object) + '?.' + expr.key"""))
        (if (=== expr.tag 'null-coalesce-expr')
          (raw """return '(' + emitExpr(expr.left) + ' ?? ' + emitExpr(expr.right) + ')'"""))
        (if (=== expr.tag 'operator-expr')
          (raw """return emitOperator(expr)"""))
        (raw """throw new Error('emitExpr: unexpected tag ' + expr.tag)"""))))
    (emitLambda
      (lambda ((node))
        (let* ((params (node.params.join ', '))
               (body (node.body.map emitStmt)))
          (raw """return '(' + params + ') => {\n' + indent(body.join('\n')) + '\n}'"""))))
    (emitNew
      (lambda ((node))
        (let* ((body (array))
               (args (node.args.map emitExpr)))
          (body.push "new ")
          (body.push node.clazz)
          (body.push "\u0028")
          (if (> args.length 0)
            (body.push (args.join ', ')))
          (body.push "\u0029")
          (return (body.join ''))
        )
      )
    )
    (emitCall
      (lambda ((node))
        (if (raw """node.fn.tag === 'identifier' && node.fn.name === 'raw' && node.args.length === 1 && node.args[0].tag === 'literal'""")
          (raw """return node.args[0].value"""))
        (let* ((fn (emitExpr node.fn))
               (args (node.args.map emitExpr)))
          (if (=== node.fn.tag 'lambda')
            (raw """return '(' + fn + ')(' + args.join(', ') + ')'"""))
          (raw """return fn + '(' + args.join(', ') + ')'"""))))
    (emitOperator
      (lambda ((node))
        (let* ((args (node.args.map emitExpr)))
          (if (=== args.length 1)
            (raw """return '(' + node.op + args[0] + ')'"""))
          (raw """return '(' + args[0] + ' ' + node.op + ' ' + args[1] + ')'"""))))
    ;; ========== main ==========
    (main
      (lambda ()
        (let* ((input (fs.readFileSync (raw """process.argv[2]""") 'utf-8'))
               (inputStream (CharStream.fromString input))
               (lexer (raw """new Stage3BLexer(inputStream)"""))
               (tokenStream (raw """new CommonTokenStream(lexer)"""))
               (parser (raw """new Stage3BParser(tokenStream)"""))
               (tree (parser.program))
               ;; Phase A: CST → surface AST
               (surfaceAst (astProgram tree))
               ;; Phase B: lowering → canonical AST
               (canonicalAst (lowerProgram surfaceAst)))
          ;; Phase C: codegen → TypeScript
          (console.log (emitProgram canonicalAst)))))
    ;; end of let*
   )
   (main)
  )
)
