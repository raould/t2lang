(program
  (import (object (:named (array (object (:name "CharStream")) (object (:name "CommonTokenStream"))))) "antlr4ng")
  (import (object (:named (array (object (:name "Stage3CLexer"))))) "./Stage3CLexer")
  (import (object (:named (array (object (:name "BindingContext")) (object (:name "ParamContext")) (object (:name "Stage3CParser"))))) "./Stage3CParser")
  (import (object (:default "fs")) "node:fs")
  (let*
   (
    ;; ========== helpers ==========
    (dbg (lambda ((...msgs)) ((. console error) msgs)))
    (parseString
      (lambda ((tokenText))
        (let* ((raw_ tokenText))
          (if ((. raw_ startsWith) '"""')
            (return ((. raw_ slice) 3 -3)))
          (let* ((inner ((. raw_ slice) 1 -1)))
            (return ((. JSON parse) (+ '"' ((. inner replace) /"/g '\\"') '"')))))))
    (indent
      (lambda ((text))
        (return ((. ((. ((. text split) '\n') map) (lambda ((line)) (return (+ '  ' line)))) join) '\n'))))
    (isDefined
      (lambda ((val))
        (return (!== val undefined))))
    (isOperator
      (lambda ((name))
        (let* ((ops (array "<" ">" "<=" ">=" "&&" "||" "!=" "!==" "==" "==="
                  "+" "-" "*" "/" "%" "^" "!")))
        (return ((. ops includes) name)))))
    ;; ========== Phase A: CST → Surface AST ==========
    (astProgram
      (lambda ((ctx))
        (let* ((body ((. ((. ctx topLevel)) map) astTopLevel)))
          (return (object (tag 'program') (body body))))))
    (astTopLevel
      (lambda ((ctx))
        (if ((. ctx "defmacro"))
          (return (astDefmacro ((. ctx "defmacro")))))
        (if ((. ctx "def"))
          (return (astDef ((. ctx "def")))))
        (return (astStatement ((. ctx statement))))))
    (astDefmacro
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (params ((. ((. ((. ctx fnSignature)) param)) map) (lambda ((p)) (return ((. ((. p IDENTIFIER)) getText))))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'defmacro') (name name) (params params) (body body))))))
    (astDef
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (init (astExpression ((. ctx expression)))))
          (return (object (tag 'def') (name name) (init init))))))
    (astStatement
      (lambda ((ctx))
        (if ((. ctx letStar))
          (return (astLetStar ((. ctx letStar)))))
        (if ((. ctx letStmt))
          (return (astLetStmt ((. ctx letStmt)))))
        (if ((. ctx constStar))
          (return (astConstStar ((. ctx constStar)))))
        (if ((. ctx constStmt))
          (return (astConstStmt ((. ctx constStmt)))))
        (if ((. ctx ifForm))
          (return (astIf ((. ctx ifForm)))))
        (if ((. ctx whileForm))
          (return (astWhile ((. ctx whileForm)))))
        (if ((. ctx block))
          (return (astBlock ((. ctx block)))))
        (if ((. ctx "assign"))
          (return (astAssign ((. ctx "assign")))))
        (if ((. ctx returnForm))
          (return (astReturn ((. ctx returnForm)))))
        (if ((. ctx throwForm))
          (return (astThrow ((. ctx throwForm)))))
        (if ((. ctx importForm))
          (return (astImport ((. ctx importForm)))))
        (if ((. ctx switchForm))
          (return (astSwitch ((. ctx switchForm)))))
        (if ((. ctx forForm))
          (return (astFor ((. ctx forForm)))))
        (if ((. ctx forInForm))
          (return (astForIn ((. ctx forInForm)))))
        (if ((. ctx forOfForm))
          (return (astForOf ((. ctx forOfForm)))))
        (let* ((expr (astExpression ((. ctx expression)))))
          (return (object (tag 'expr-stmt') (expr expr))))))
    (astThrow
      (lambda ((ctx))
        (let* ((expr (astExpression ((. ctx expression)))))
          (return (object (tag 'throw') (expr expr))))))
    (astImport
      (lambda ((ctx))
        (let* ((spec (ternary ((. ctx objectExpr)) (astObjectExpr ((. ctx objectExpr))) undefined))
               (source (parseString ((. ((. ctx STRING)) getText)))))
          (return (object (tag 'import') (spec spec) (source source))))))
    (astSwitch
      (lambda ((ctx))
        (let* ((discriminant (astExpression ((. ctx expression))))
               (cases ((. ((. ctx caseClause)) map) (lambda ((c))
                 (let* ((test (astExpression ((. c expression))))
                        (body ((. ((. c statement)) map) astStatement)))
                   (return (object (test test) (body body)))))))
               (defCtx ((. ctx defaultClause)))
               (defaultCase (ternary defCtx (object (body ((. ((. defCtx statement)) map) astStatement))) undefined)))
          (return (object (tag 'switch') (discriminant discriminant) (cases cases) (defaultCase defaultCase))))))
    (astFor
      (lambda ((ctx))
        (let* ((initCtx ((. ctx letStmt)))
               (initName ((. ((. initCtx IDENTIFIER)) getText)))
               (initExpr (astExpression ((. initCtx expression))))
               (test (astExpression ((. ctx expression))))
               (updateCtx ((. ctx "assign")))
               (updateName ((. ((. updateCtx IDENTIFIER)) getText)))
               (updateExpr (astExpression ((. updateCtx expression))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'for') (initName initName) (initExpr initExpr) (test test) (updateName updateName) (updateExpr updateExpr) (body body))))))
    (astForIn
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (obj (astExpression ((. ctx expression))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'for-in') (name name) ("object" obj) (body body))))))
    (astForOf
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (iterable (astExpression ((. ctx expression))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'for-of') (name name) (iterable iterable) (body body))))))
    (astLetStar
      (lambda ((ctx))
        (let* ((bindings ((. ((. ctx binding)) map) (lambda ((b))
                 (let* ((id ((. ((. b IDENTIFIER)) getText)))
                        (init (ternary ((. b expression)) (astExpression ((. b expression))) undefined)))
                   (return (object (name id) (init init)))))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'let*') (bindings bindings) (body body))))))
    (astLetStmt
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (init (astExpression ((. ctx expression)))))
          (return (object (tag 'let') (name name) (init init))))))
    (astConstStar
      (lambda ((ctx))
        (let* ((bindings ((. ((. ctx binding)) map) (lambda ((b))
                 (let* ((id ((. ((. b IDENTIFIER)) getText)))
                        (init (ternary ((. b expression)) (astExpression ((. b expression))) undefined)))
                   (return (object (name id) (init init)))))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'const*') (bindings bindings) (body body))))))
    (astConstStmt
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (init (astExpression ((. ctx expression)))))
          (return (object (tag 'const') (name name) (init init))))))
    (astIf
      (lambda ((ctx))
        (let* ((test (astExpression ((. ctx expression))))
               (ifthen (astStatement ((. ctx statement) 0)))
               (ctxElse ((. ctx statement) 1))
               (ifelse (ternary ctxElse (astStatement ctxElse) undefined)))
          (return (object (tag 'if') (test test) (ifthen ifthen) (ifelse ifelse))))))
    (astWhile
      (lambda ((ctx))
        (let* ((test (astExpression ((. ctx expression))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'while') (test test) (body body))))))
    (astBlock
      (lambda ((ctx))
        (let* ((body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'block') (body body))))))
    (astReturn
      (lambda ((ctx))
        (let* ((expr (ternary ((. ctx expression)) (astExpression ((. ctx expression))) undefined)))
          (return (object (tag 'return') (expr expr))))))
    ;; Stage 3 additions
    (astObjectExpr
      (lambda ((ctx))
        (let* ((fields ((. ((. ctx objectField)) map) (lambda ((f))
                 (let* ((key))
                   (if ((. f IDENTIFIER))
                     (set! key ((. ((. f IDENTIFIER)) getText))))
                   (if ((. f KEYWORD))
                     (set! key ((. ((. f KEYWORD)) getText))))
                   (if ((. f STRING))
                     (set! key (parseString ((. ((. f STRING)) getText)))))
                   (let* ((value (astExpression ((. f expression)))))
                     (return (object (key key) (value value)))))))))
          (return (object (tag 'object') (fields fields))))))
    (astArrayExpr
      (lambda ((ctx))
        (let* ((elements ((. ((. ctx expression)) map) astExpression)))
          (return (object (tag 'array') (elements elements))))))
    (astQuasiquote
      (lambda ((ctx))
        (let* ((expr (astExpression ((. ctx expression)))))
          (return (object (tag 'quasi') (expr expr))))))
    (astUnquote
      (lambda ((ctx))
        (let* ((expr (astExpression ((. ctx expression)))))
          (return (object (tag 'unquote') (expr expr))))))
    (astUnquoteSplicing
      (lambda ((ctx))
        (let* ((expr (astExpression ((. ctx expression)))))
          (return (object (tag 'unquote-splicing') (expr expr))))))
    (astTernary
      (lambda ((ctx))
        (let* ((test (astExpression ((. ctx expression) 0)))
               (ifthen (astExpression ((. ctx expression) 1)))
               (ifelse (astExpression ((. ctx expression) 2))))
          (return (object (tag 'ternary') (test test) (ifthen ifthen) (ifelse ifelse))))))
    (astCondExpr
      (lambda ((ctx))
        (let* ((exprs ((. ((. ctx expression)) map) astExpression))
               (clauses (array))
               (i 0))
          (while (< i (. exprs length))
						((. clauses push) (object (test (index exprs i)) (expr (index exprs (+ i 1)))))
            (set! i (+ i 2)))
          (return (object (tag 'cond') (clauses clauses))))))
    (astNewExpr
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (args ((. ((. ctx expression)) map) astExpression)))
          (return (object (tag 'new') (name name) (args args))))))
    (astOptChain
      (lambda ((ctx))
        (let* ((obj (astExpression ((. ctx expression))))
               (prop ((. ((. ctx IDENTIFIER)) getText))))
          (return (object (tag 'opt-chain') ("object" obj) (key prop))))))
    (astNullCoalesce
      (lambda ((ctx))
        (let* ((left (astExpression ((. ctx expression) 0)))
               (right (astExpression ((. ctx expression) 1))))
          (return (object (tag 'null-coalesce') (left left) (right right))))))
    (astExpression
      (lambda ((ctx))
        (if (== ctx undefined)
          (begin
            ((. console error) 'astExpression: ctx is undefined or null')
            (return (object (tag 'error') (reason 'ctx undefined')))))
        (if ((. ctx literal))
          (return (astLiteral ((. ctx literal)))))
        (if ((. ctx KEYWORD))
          (return (object (tag 'keyword') (value ((. ((. ctx KEYWORD)) getText))))))
        (if ((. ctx IDENTIFIER))
          (let* ((text ((. ((. ctx IDENTIFIER)) getText))))
            (if ((. text includes) '.')
              (throw (new Error (+ "Invalid use of dotted identifier: " text ". Use (. obj prop) syntax instead."))))
            (return (object (tag 'identifier') (name text)))))
        (if ((. ctx "lambda"))
          (return (astLambda ((. ctx "lambda")))))
        (if ((. ctx objectExpr))
          (return (astObjectExpr ((. ctx objectExpr)))))
        (if ((. ctx arrayExpr))
          (return (astArrayExpr ((. ctx arrayExpr)))))
        (if ((. ctx propAccess))
          (return (astPropAccess ((. ctx propAccess)))))
        (if ((. ctx indexAccess))
          (return (astIndexAccess ((. ctx indexAccess)))))
        (if ((. ctx quasiquote))
          (return (astQuasiquote ((. ctx quasiquote)))))
        (if ((. ctx "unquote"))
          (return (astUnquote ((. ctx "unquote")))))
        (if ((. ctx unquoteSplicing))
          (return (astUnquoteSplicing ((. ctx unquoteSplicing)))))
        (if ((. ctx "ternary"))
          (return (astTernary ((. ctx "ternary")))))
        (if ((. ctx condExpr))
          (return (astCondExpr ((. ctx condExpr)))))
        (if ((. ctx newForm))
          (return (astNewExpr ((. ctx newForm)))))
        (if ((. ctx optChain))
          (return (astOptChain ((. ctx optChain)))))
        (if ((. ctx nullCoalesce))
          (return (astNullCoalesce ((. ctx nullCoalesce)))))
        (if ((. ctx call))
          (return (astCall ((. ctx call)))))
        (throw (new Error (+ 'Unknown expression: ' (ternary (. ctx getText) ((. ctx getText)) ctx))))))
    (astPropAccess
      (lambda ((ctx))
        (let* ((obj (astExpression ((. ctx expression))))
               (key))
          (if ((. ctx IDENTIFIER))
            (set! key ((. ((. ctx IDENTIFIER)) getText))))
          (if ((. ctx KEYWORD))
            (set! key ((. ((. ctx KEYWORD)) getText))))
          (if ((. ctx STRING))
            (set! key (parseString ((. ((. ctx STRING)) getText)))))
          (return (object (tag 'prop-access') ("object" obj) (key key))))))
    (astIndexAccess
      (lambda ((ctx))
        (let* ((obj (astExpression ((. ctx expression) 0)))
               (idx (astExpression ((. ctx expression) 1))))
          (return (object (tag 'index-access') ("object" obj) ("index" idx))))))
    (astLambda
      (lambda ((ctx))
        (let* ((params ((. ((. ((. ctx fnSignature)) param)) map) (lambda ((p)) (return ((. ((. p IDENTIFIER)) getText))))))
               (body ((. ((. ctx statement)) map) astStatement)))
          (return (object (tag 'lambda') (params params) (body body))))))
    (astAssign
      (lambda ((ctx))
        (let* ((name ((. ((. ctx IDENTIFIER)) getText)))
               (value (astExpression ((. ctx expression)))))
          (return (object (tag "assign") (name name) (value value))))))
    (astCall
      (lambda ((ctx))
        (let* ((exprs ((. ((. ctx expression)) map) astExpression)))
          (return (object (tag 'call') (fn (index exprs 0)) (args ((. exprs slice) 1)))))))
    (astLiteral
      (lambda ((ctx))
        (if ((. ctx NUMBER))
          (return (object (tag 'literal') (value (Number ((. ((. ctx NUMBER)) getText)))))))
        (if ((. ctx STRING))
          (return (object (tag 'literal') (value (parseString ((. ((. ctx STRING)) getText)))))))
        (if ((. ctx BOOLEAN))
          (return (object (tag 'literal') (value (=== ((. ((. ctx BOOLEAN)) getText)) 'true')))))
        (if ((. ctx NULL))
          (return (object (tag 'literal') (value null))))
        (if ((. ctx UNDEFINED))
          (return (object (tag 'literal') (value undefined))))
        (throw (new Error 'Unknown literal'))))
    ;; ========== Phase B: Lowering ==========
    (lowerProgram
      (lambda ((node))
        (let* ((body ((. (. node body) map) lowerTopLevel)))
          (return (object (tag 'program') (body body))))))
    (lowerTopLevel
      (lambda ((node))
        (if (=== (. node tag) 'defmacro')
          (return (lowerDefmacro node)))
        (if (=== (. node tag) 'def')
          (return (lowerDef node)))
        (return (lowerStmt node))))
    (lowerDefmacro
      (lambda ((node))
        (let* ((body ((. (. node body) map) lowerStmt)))
          (return (object (tag 'defmacro') (name (. node name)) (params (. node params)) (body body))))))
    (lowerDef
      (lambda ((node))
        (let* ((init (lowerExpr (. node init))))
          (return (object (tag 'let-stmt') (name (. node name)) (init init))))))
    (lowerStmt
      (lambda ((node))
        (if (=== (. node tag) 'let*')
          (return (lowerLetStar node)))
        (if (=== (. node tag) 'let')
          (return (object (tag 'let-stmt') (name (. node name)) (init (lowerExpr (. node init))))))
        (if (=== (. node tag) 'const*')
          (return (lowerConstStar node)))
        (if (=== (. node tag) 'const')
          (return (object (tag 'const-stmt') (name (. node name)) (init (lowerExpr (. node init))))))
        (if (=== (. node tag) 'if')
          (return (object (tag 'if-stmt') (test (lowerExpr (. node test))) (ifthen (lowerStmt (. node ifthen))) (ifelse (ternary (. node ifelse) (lowerStmt (. node ifelse)) undefined)))))
        (if (=== (. node tag) 'while')
          (return (object (tag 'while-stmt') (test (lowerExpr (. node test))) (body ((. (. node body) map) lowerStmt)))))
        (if (=== (. node tag) 'block')
          (return (object (tag 'block-stmt') (body ((. (. node body) map) lowerStmt)))))
        (if (=== (. node tag) 'return')
          (return (object (tag 'return-stmt') (expr (ternary (. node expr) (lowerExpr (. node expr)) undefined)))))
        (if (=== (. node tag) 'assign')
          (return (object (tag 'assign-stmt') (name (. node name)) (value (lowerExpr (. node value))))))
        (if (=== (. node tag) 'throw')
          (return (object (tag 'throw-stmt') (expr (lowerExpr (. node expr))))))
        (if (=== (. node tag) 'import')
          (return (lowerImport node)))
        (if (=== (. node tag) 'switch')
          (return (lowerSwitch node)))
        (if (=== (. node tag) 'for')
          (return (object (tag 'for-stmt') (initName (. node initName)) (initExpr (lowerExpr (. node initExpr))) (test (lowerExpr (. node test))) (updateName (. node updateName)) (updateExpr (lowerExpr (. node updateExpr))) (body ((. (. node body) map) lowerStmt)))))
        (if (=== (. node tag) 'for-in')
          (return (object (tag 'for-in-stmt') (name (. node name)) ("object" (lowerExpr (. node "object"))) (body ((. (. node body) map) lowerStmt)))))
        (if (=== (. node tag) 'for-of')
          (return (object (tag 'for-of-stmt') (name (. node name)) (iterable (lowerExpr (. node iterable))) (body ((. (. node body) map) lowerStmt)))))
        (if (=== (. node tag) 'expr-stmt')
          (return (object (tag 'expr-stmt') (expr (lowerExpr (. node expr))))))
        (throw (new Error (+ 'lowerStmt: unexpected tag >' (. node tag) '<')))))
    (lowerLetStar
      (lambda ((node))
        (let* ((stmts (array)))
          ((. (. node bindings) forEach) (lambda ((b))
            ((. stmts push) (object (tag 'let-stmt') (name (. b name)) (init (cond (. b init) (lowerExpr (. b init)) :else undefined))))))
          ((. (. node body) forEach) (lambda ((s))
            ((. stmts push) (lowerStmt s))))
          (return (object (tag 'block-stmt') (body stmts))))))
    (lowerConstStar
      (lambda ((node))
        (let* ((stmts (array)))
          ((. (. node bindings) forEach) (lambda ((b))
            ((. stmts push) (object (tag 'const-stmt') (name (. b name)) (init (cond (. b init) (lowerExpr (. b init)) :else undefined))))))
          ((. (. node body) forEach) (lambda ((s))
            ((. stmts push) (lowerStmt s))))
          (return (object (tag 'block-stmt') (body stmts))))))
    (lowerImport
      (lambda ((node))
        (let* ((spec (. node spec))
               (defaultName undefined)
               (namespaceName undefined)
               (named undefined))
          (if spec
            ((. (. spec fields) forEach) (lambda ((f))
              (if (=== (. f key) ':default')
                (set! defaultName (. (. f value) value)))
              (if (=== (. f key) ':namespace')
                (set! namespaceName (. (. f value) value)))
              (if (=== (. f key) ':named')
                (set! named ((. (. (. f value) elements) map) (lambda ((el))
                  (let* ((nm undefined)
                         (al undefined))
                    ((. (. el fields) forEach) (lambda ((ff))
                      (if (=== (. ff key) ':name')
                        (set! nm (. (. ff value) value)))
                      (if (=== (. ff key) ':as')
                        (set! al (. (. ff value) value)))))
                    (return (object (name nm) ("alias" al)))))))))))
          (return (object (tag 'import-stmt') (defaultName defaultName) (namespaceName namespaceName) (named named) (source (. node source)))))))
    (lowerSwitch
      (lambda ((node))
        (let* ((discriminant (lowerExpr (. node discriminant)))
               (cases ((. (. node cases) map) (lambda ((c))
                 (return (object (test (lowerExpr (. c test))) (body ((. (. c body) map) lowerStmt)))))))
               (defaultCase (ternary (. node defaultCase) (object (body ((. (. (. node defaultCase) body) map) lowerStmt))) undefined)))
          (return (object (tag 'switch-stmt') (discriminant discriminant) (cases cases) (defaultCase defaultCase))))))
    (lowerExpr
      (lambda ((node))
        (if (=== (. node tag) 'prop-access')
          (return (object (tag 'prop-access-expr') ("object" (lowerExpr (. node "object"))) (key (. node key)))))
        (if (=== (. node tag) 'index-access')
          (return (object (tag 'index-access-expr') ("object" (lowerExpr (. node "object"))) ("index" (lowerExpr (. node "index"))))))
        (if (=== (. node tag) 'literal')
          (return node))
        (if (=== (. node tag) 'keyword')
          (return node))
        (if (=== (. node tag) 'identifier')
          (return node))
        (if (=== (. node tag) 'lambda')
          (return (object (tag 'lambda') (params (. node params)) (body ((. (. node body) map) lowerStmt)))))
        (if (=== (. node tag) 'object')
          (return (object (tag 'object-expr') (fields ((. (. node fields) map) (lambda ((f)) (return (object (key (. f key)) (value (lowerExpr (. f value)))))))))))
        (if (=== (. node tag) 'array')
          (return (object (tag 'array-expr') (elements ((. (. node elements) map) lowerExpr)))))
        (if (=== (. node tag) 'quasi')
          (return (object (tag 'quasi-expr') (expr (lowerExpr (. node expr))))))
        (if (=== (. node tag) 'unquote')
          (return (object (tag 'unquote-expr') (expr (lowerExpr (. node expr))))))
        (if (=== (. node tag) 'unquote-splicing')
          (return (object (tag 'unquote-splicing-expr') (expr (lowerExpr (. node expr))))))
        (if (=== (. node tag) 'ternary')
          (return (object (tag 'ternary-expr') (test (lowerExpr (. node test))) (ifthen (lowerExpr (. node ifthen))) (ifelse (lowerExpr (. node ifelse))))))
        (if (=== (. node tag) 'cond')
          (return (lowerCond node)))
        (if (=== (. node tag) 'new')
          (return (object (tag 'new-expr') (name (. node name)) (args ((. (. node args) map) lowerExpr)))))
        (if (=== (. node tag) 'opt-chain')
          (return (object (tag 'opt-chain-expr') ("object" (lowerExpr (. node "object"))) (key (. node key)))))
        (if (=== (. node tag) 'null-coalesce')
          (return (object (tag 'null-coalesce-expr') (left (lowerExpr (. node left))) (right (lowerExpr (. node right))))))
        (if (=== (. node tag) 'call')
          (return (lowerCall node)))
        (throw (new Error (+ 'lowerExpr: unexpected tag >' (. node tag) '<')))))
    (lowerCall
      (lambda ((node))
        (if (&& (=== (. (. node fn) tag) 'identifier') (isOperator (. (. node fn) name)))
          (let* ((op (. (. node fn) name))
                 (args ((. (. node args) map) lowerExpr)))
            (if (=== (. args length) 1)
              (return (object (tag 'operator-expr') (op op) (args args))))
            (let* ((result (object (tag 'operator-expr') (op op) (args (array (index args 0) (index args 1)))))
                   (i 2))
              (while (< i (. args length))
                (set! result (object (tag 'operator-expr') (op op) (args (array result (index args i)))))
                (set! i (+ i 1)))
              (return result))))
        (return (object (tag 'call') (fn (lowerExpr (. node fn))) (args ((. (. node args) map) lowerExpr))))))
    (lowerCond
      (lambda ((node))
        (let* ((clauses (. node clauses))
               (i (- (. clauses length) 1))
               (last (index clauses i))
               (result (object (tag 'ternary-expr') (test (lowerExpr (. last test))) (ifthen (lowerExpr (. last expr))) (ifelse (object (tag 'literal') (value undefined))))))
          (set! i (- i 1))
          (while (>= i 0)
            (let* ((c (index clauses i)))
              (set! result (object (tag 'ternary-expr') (test (lowerExpr (. c test))) (ifthen (lowerExpr (. c expr))) (ifelse result))))
            (set! i (- i 1)))
          (return result))))
    ;; ========== Phase C: Codegen ==========
    (emitProgram
      (lambda ((node))
        (return ((. ((. (. node body) map) emitTopLevel) join) '\n'))))
    (emitTopLevel
      (lambda ((node))
        (if (=== (. node tag) 'defmacro')
          (return (+ '// macro: ' (. node name))))
        (return (emitStmt node))))
    (emitStmt
      (lambda ((stmt))
        (if (=== (. stmt tag) 'let-stmt')
          (if (isDefined (. stmt init))
            (return (+ 'let ' (. stmt name) ' = ' (emitExpr (. stmt init)) ';'))
            (return (+ 'let ' (. stmt name) ';'))))
        (if (=== (. stmt tag) 'const-stmt')
          (if (isDefined (. stmt init))
            (return (+ 'const ' (. stmt name) ' = ' (emitExpr (. stmt init)) ';'))
            (return (+ 'const ' (. stmt name) ';'))))
        (if (=== (. stmt tag) 'if-stmt')
          (return (emitIf stmt)))
        (if (=== (. stmt tag) 'while-stmt')
          (return (emitWhile stmt)))
        (if (=== (. stmt tag) 'block-stmt')
          (return (emitBlock stmt)))
			  (if (=== (. stmt tag) 'assign-stmt')
				  (return (+ (. stmt name) " = " (emitExpr (. stmt value)) ';')))
        (if (=== (. stmt tag) 'return-stmt')
          (if (. stmt expr)
            (return (+ 'return ' (emitExpr (. stmt expr)) ';'))
            (return 'return;')))
        (if (=== (. stmt tag) 'throw-stmt')
          (return (+ 'throw ' (emitExpr (. stmt expr)) ';')))
        (if (=== (. stmt tag) 'import-stmt')
          (return (emitImport stmt)))
        (if (=== (. stmt tag) 'switch-stmt')
          (return (emitSwitch stmt)))
        (if (=== (. stmt tag) 'for-stmt')
          (return (emitFor stmt)))
        (if (=== (. stmt tag) 'for-in-stmt')
          (return (emitForIn stmt)))
        (if (=== (. stmt tag) 'for-of-stmt')
          (return (emitForOf stmt)))
        (if (=== (. stmt tag) 'expr-stmt')
          (return (+ (emitExpr (. stmt expr)) ';')))
        (throw (new Error (+ 'emitStmt: unexpected tag >' (. stmt tag) '<')))))
    (emitIf
      (lambda ((node))
        (let* ((lines (array)))
          ((. lines push) (+ 'if (' (emitExpr (. node test)) ') {'))
          ((. lines push) (indent (emitStmt (. node ifthen))))
          ((. lines push) '}')
          (if (isDefined (. node ifelse))
            (let* ()
              ((. lines push) 'else {')
              ((. lines push) (indent (emitStmt (. node ifelse))))
              ((. lines push) '}')))
          (return ((. lines join) '\n')))))
    (emitWhile
      (lambda ((node))
        (let* ((lines (array)))
          ((. lines push) (+ 'while (' (emitExpr (. node test)) ') {'))
          ((. (. node body) forEach) (lambda ((s))
            ((. lines push) (indent (emitStmt s)))))
          ((. lines push) '}')
          (return ((. lines join) '\n')))))
    (emitBlock
      (lambda ((node))
        (let* ((lines (array '{')))
          ((. (. node body) forEach) (lambda ((s))
            ((. lines push) (indent (emitStmt s)))))
          ((. lines push) '}')
          (return ((. lines join) '\n')))))
    (emitImport
      (lambda ((node))
        (let* ((parts (array)))
          (if (. node defaultName)
            ((. parts push) (. node defaultName)))
          (if (. node namespaceName)
            ((. parts push) (+ '* as ' (. node namespaceName))))
          (if (. node named)
            (let* ((specs ((. (. node named) map) (lambda ((n))
                     (if (. n "alias")
                       (return (+ (. n name) ' as ' (. n "alias")))
                       (return (. n name)))))))
              ((. parts push) (+ '{ ' ((. specs join) ', ') ' }'))))
          (if (> (. parts length) 0)
            (return (+ 'import ' ((. parts join) ', ') ' from ' ((. JSON stringify) (. node source)) ';')))
          (return (+ 'import ' ((. JSON stringify) (. node source)) ';')))))
    (emitSwitch
      (lambda ((node))
        (let* ((lines (array)))
          ((. lines push) (+ 'switch (' (emitExpr (. node discriminant)) ') {'))
          ((. (. node cases) forEach) (lambda ((c))
            ((. lines push) (+ '  case ' (emitExpr (. c test)) ':'))
            ((. (. c body) forEach) (lambda ((s))
              ((. lines push) (indent (indent (emitStmt s))))))
            ((. lines push) '    break;')))
          (if (. node defaultCase)
            (begin
              ((. lines push) '  default:')
              ((. (. (. node defaultCase) body) forEach) (lambda ((s))
                ((. lines push) (indent (indent (emitStmt s))))))))
          ((. lines push) '}')
          (return ((. lines join) '\n')))))
    (emitFor
      (lambda ((node))
        (let* ((lines (array))
               (init (+ 'let ' (. node initName) ' = ' (emitExpr (. node initExpr))))
               (test (emitExpr (. node test)))
               (update (+ (. node updateName) ' = ' (emitExpr (. node updateExpr)))))
          ((. lines push) (+ 'for (' init '; ' test '; ' update ') {'))
          ((. (. node body) forEach) (lambda ((s))
            ((. lines push) (indent (emitStmt s)))))
          ((. lines push) '}')
          (return ((. lines join) '\n')))))
    (emitForIn
      (lambda ((node))
        (let* ((lines (array)))
          ((. lines push) (+ 'for (const ' (. node name) ' in ' (emitExpr (. node "object")) ') {'))
          ((. (. node body) forEach) (lambda ((s))
            ((. lines push) (indent (emitStmt s)))))
          ((. lines push) '}')
          (return ((. lines join) '\n')))))
    (emitForOf
      (lambda ((node))
        (let* ((lines (array)))
          ((. lines push) (+ 'for (const ' (. node name) ' of ' (emitExpr (. node iterable)) ') {'))
          ((. (. node body) forEach) (lambda ((s))
            ((. lines push) (indent (emitStmt s)))))
          ((. lines push) '}')
          (return ((. lines join) '\n')))))
    (emitExpr
      (lambda ((expr))
        (if (=== (. expr tag) 'prop-access-expr')
          (return (+ (emitExpr (. expr "object")) '.' (. expr key))))
        (if (=== (. expr tag) 'index-access-expr')
          (return (+ (emitExpr (. expr "object")) '[' (emitExpr (. expr "index")) ']')))
        (if (=== (. expr tag) 'literal')
          (return ((. JSON stringify) (. expr value))))
        (if (=== (. expr tag) 'keyword')
          (return ((. JSON stringify) (. expr value))))
        (if (=== (. expr tag) 'identifier')
          (return (. expr name)))
        (if (=== (. expr tag) 'object-expr')
          (return (+ '({' ((. ((. (. expr fields) map) (lambda ((f)) (return (+ (. f key) ': ' (emitExpr (. f value)))))) join) ', ') '})')))
        (if (=== (. expr tag) 'array-expr')
          (return (+ '[' ((. ((. (. expr elements) map) emitExpr) join) ', ') ']')))
        (if (=== (. expr tag) 'quasi-expr')
          (return (+ '/* quasiquote */ ' (emitExpr (. expr expr)))))
        (if (=== (. expr tag) 'unquote-expr')
          (return (+ '/* unquote */ ' (emitExpr (. expr expr)))))
        (if (=== (. expr tag) 'unquote-splicing-expr')
          (return (+ '/* unquote-splicing */ ' (emitExpr (. expr expr)))))
        (if (=== (. expr tag) 'ternary-expr')
          (return (+ '(' (emitExpr (. expr test)) ' ? ' (emitExpr (. expr ifthen)) ' : ' (emitExpr (. expr ifelse)) ')')))
        (if (=== (. expr tag) 'call')
          (return (emitCall expr)))
        (if (=== (. expr tag) 'lambda')
          (return (emitLambda expr)))
        (if (=== (. expr tag) 'new-expr')
          (return (+ 'new ' (. expr name) '(' ((. ((. (. expr args) map) emitExpr) join) ', ') ')')))
        (if (=== (. expr tag) 'opt-chain-expr')
          (return (+ (emitExpr (. expr "object")) '?.' (. expr key))))
        (if (=== (. expr tag) 'null-coalesce-expr')
          (return (+ '(' (emitExpr (. expr left)) ' ?? ' (emitExpr (. expr right)) ')')))
        (if (=== (. expr tag) 'operator-expr')
          (return (emitOperator expr)))
        (throw (new Error (+ 'emitExpr: unexpected tag >' (. expr tag) '<')))))
    (emitLambda
      (lambda ((node))
        (let* ((params ((. (. node params) join) ', '))
               (body ((. (. node body) map) emitStmt)))
          (return (+ '(' params ') => {\n' (indent ((. body join) '\n')) '\n}')))))
    (emitCall
      (lambda ((node))
        (let* ((fn (emitExpr (. node fn)))
               (args ((. (. node args) map) emitExpr)))
          (if (=== (. (. node fn) tag) 'lambda')
            (return (+ '(' fn ')(' ((. args join) ', ') ')')))
          (return (+ fn '(' ((. args join) ', ') ')')))))
    (emitOperator
      (lambda ((node))
        (let* ((args ((. (. node args) map) emitExpr)))
          (if (=== (. args length) 1)
            (return (+ '(' (. node op) (index args 0) ')')))
          (return (+ '(' (index args 0) ' ' (. node op) ' ' (index args 1) ')')))))
    ;; ========== main ==========
    (main
      (lambda ()
        (let* ((input ((. fs readFileSync) (index (. process argv) 2) 'utf-8'))
               (inputStream ((. CharStream fromString) input))
               (lexer (new Stage3CLexer inputStream))
               (tokenStream (new CommonTokenStream lexer))
               (parser (new Stage3CParser tokenStream))
               (tree ((. parser "program")))
               ;; Phase A: CST → surface AST
               (surfaceAst (astProgram tree))
               ;; Phase B: lowering → canonical AST
               (canonicalAst (lowerProgram surfaceAst)))
          ;; Phase C: codegen → TypeScript
          ((. console log) (emitProgram canonicalAst)))))
    ;; end of let*
   )
   (main)
  )
)
