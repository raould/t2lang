PhaseA canonical AST now records detailed `TypeParam` metadata (variance, `const`, `infer`). When wiring the resolver/typechecker, ensure these flags influence variance checking, const inference, and `infer` handling so the generics implementation honors Phase B’s rewrites.
Extend this metadata so `constraint` can carry intersections/unions (for `extends A & B`), and Phase B sets `infer = true` only when a conditional type introduces the binding alongside contextual hints (e.g., which conditional type or inference target it belongs to). Use the `infer` flag to drive deferred inference instead of inventing additional AST nodes.
Design the error registry loader: read `phaseA/errors/reg_errors.json`, treat every message as a literal string (no interpolation), and append runtime data (locations, tokens) separately when emitting diagnostics. Maintain categories/severities there so downstream tooling can filter by parse/type/codegen. IDs must be the fully qualified strings with the `T2:` prefix so search engines can index the canonical reference, and future subsystems can reserve their own prefixes if needed.
Parser recovery helpers should emit a registry entry when encountering malformed syntax, then skip to the next statement boundary (respect balancing tokens) so we can continue building a partial AST. Ensure downstream stages can detect the errored subtree, stop codegen, but still produce traces/logs for the remainder of the file.

Precedence-sensitive behaviors need their own regression infrastructure. Keep a TypeScript-only suite of fixtures whose runtime outputs would differ if any of the TypeScript-only operators (`extends`, `infer`, `keyof`, `typeof`, `? :`, `[]`, etc.) re-associate, and compile each fixture with `tsc`/`node` to capture the gold output. Then author matching t2lang fixtures that exercise Phase B’s sugar/infix layer and run them through `t2lang → .ts → tsc → .js → node`, asserting the runtime results match the TypeScript baseline. This end-to-end pairing makes it obvious when a precedence tweak in the sugar or rewrite layer drifts away from the TypeScript semantics, and it keeps the regression suite empirically maintained instead of relying on a theoretical table.

Module resolution remains the responsibility of the downstream TypeScript/JavaScript toolchain. t2lang only produces `.ts` that assume whatever module resolution rules the consumer already has configured (`tsconfig`, bundler, runtime). We intentionally avoid re-implementing path lookup, node_modules traversal, or platform-specific loading at the t2lang layer so that the emitted artifacts behave identically to hand-authoring the equivalent TypeScript.

Phase B should target distinct loop nodes rather than mutating a single `ForStmt`: emit `ForClassic`, `ForOf`, or `ForAwait` depending on whether you are rewriting a classic `for`, a `for...of`, or a `for await...of`. Each node carries exactly the fields needed by that loop form (init/cond/update vs iterator binding vs async flag) so the resolver/typechecker can treat them simply instead of unraveling nullable helpers.

Optional chaining must be rewritten in Phase B before visiting Phase A: replace controls using `?.`/`?.[]` with explicit guard statements or runtime helper expressions, and set the resulting `PropExpr`/`IndexExpr`’s `nonNull` flag to `false` so downstream stages know the receiver was not statically guaranteed. Treat `nonNull: true` as shorthand for “no guard needed,” while `false` means Phase B already ensured the necessary null/undefined check by rewriting the surrounding code. This keeps the Phase A core free of `?.` syntax and preserves explicit control-flow for diagnostics.

Mapped types must similarly be lowered in Phase B: emit `type-mapped` nodes with the bound `TypeParam`, value expression, optional `as` remapping, readonly/optional modifiers, and the `in`-source key type. Resolver/typechecker code consumes these nodes directly instead of reintroducing `in`/`as` sugar inside Phase A.

- Phase B rewrites must emit explicit parameter type names and parenthesized arrow-function type syntax whenever such types appear inside other expressions (`(s: string)=>void` is required, whereas `n => number | string` is ambiguous). Always inject the parentheses so Phase A’s parser/type checker receives the unambiguous shapes documented in `phaseA/GRAMMAR.md`.
