# Phase1 ‚Üí Phase0 Deduplication Plan üîß

## Goal üéØ
Make `t2lang-phase1` a **thin wrapper** around `t2lang-phase0` so Phase1 contains only the minimal code needed to:
- act as a compatibility/adapter layer for features unique to phase1 (e.g., macro-related parsing hooks, dev utilities), and
- reuse core parsing, resolving, typechecking and codegen from `phase0` without duplication.

This reduces maintenance, avoids drift, and centralizes bug fixes and behavior in `phase0`.

---

## Non-goal ‚ùå
- Merging the packages; this is a code dedup/refactor to call into Phase0 where appropriate, not a monorepo layout change.

---

## Scope & High-level Strategy üß≠
1. **Inventory**: Find duplicated files and APIs across `t2lang-phase1/src` and `t2lang-phase0/src`.
2. **Categorize** each duplication by feasibility: "extractable shared module", "phase1 specialization", or "incompatible".
3. **Introduce clear public APIs** in Phase0 (or a `common` package) for functionality Phase1 needs (parsing helpers, macro utilities, normalization helpers). Favor small, well-typed interfaces.
4. **Replace** Phase1 duplicates with adapters that import and call Phase0 APIs. Keep Phase1-specific logic localized to small shim modules.
5. **Tests & CI**: Add regression tests to lock in behavior. Run full test suites during each change.
6. **Iterate** in small, reviewable commits (one logical change per commit) until duplication is minimized.

---

High priority (easy wins)

sexprPrinter

Files: sexprPrinter.ts (canonical), sexprPrinter.js, sexprPrinter.ts (runtime wrapper).
Issue: Phase1 currently uses a runtime wrapper that loads the common implementation; some older compiled JS still had JSON fallback.
Action: keep sexprPrinter.ts as canonical; replace sexprPrinter.ts with a tiny static re-export once common package exports/types are stable:
export { printSexpr } from 't2lang-common/ast/sexprPrinter.js'
Benefit: single implementation, easier maintenance and tests.
cliHelper (CLI arg parsing & AST dump printing)

Files: cliHelper.ts (now canonical), cliHelper.ts (delegation), cli.js (build), cli.ts (phase1-specific wrapper).
Issue: common now holds CLI helper but compiled JS and some callers still use JSON.dump fallback.
Action: ensure all consumers import the single helper in common (update imports), remove leftover copies in phase0 if any, and regenerate builds so dist files reflect source.
Benefit: consistent CLI flags/behavior and unified AST printing.
Medium priority

Event system (EventSink, ArrayEventSink, CompilerEvent)

Files: eventSink.ts (authoritative), eventSink.ts (re-exports), many consumers across phases.
Issue: phase1 re-exports the phase0 events API; that's okay, but there's potential to centralize into common if you want common to be the cross-phase API surface.
Action: Recommendation: keep Event types in Phase0 (core) and import/re-export from other phases (current pattern). Only move to common if you're making common the canonical public API for toolchains.
AST / debug printing helpers (JSON dumps)

Files: numerous dev scripts and tests call JSON.stringify(...) (e.g., dev/*.mjs, scripts/*, tests).
Issue: inconsistent formats (some JSON, some sexpr). We already added a sexpr printer; many places still print JSON strings.
Action: Add a small common/src/debug/printAst.ts that accepts an AST and prints via printSexpr (fallback to JSON.stringify), then update dev scripts and tests to use this helper.
Benefit: consistent, readable AST output everywhere.
Lower priority / housekeeping

dist artifacts that were edited by hand

Files: cliHelper.js, other compiled JS were edited directly during debugging.
Issue: source and compiled outputs can drift if compiled JS is manually changed.
Action: revert manual edits in dist/src/*.js so they are generated by tsc; run npm -w common run build and npm -w t2lang-phase1 run build to regenerate artifacts. If you must keep manual run-time fixes, prefer editing the TypeScript source and then rebuilding.
Benefit: coherent build pipeline, fewer surprises.
tsconfig path mappings / package exports

Files: package.json (exports for sexprPrinter.js), tsconfig.json (paths mapping to .d.ts).
Issue: current workaround uses paths to point type-checking to common d.ts; once common is packaged or built consistently, it will be safe to replace runtime loaders with static imports.
Action: finalize package.json exports and index.d.ts; consider adding types to package then switch t2lang-phase1 to static imports.

---

## Progress Update (2026-01-18) ‚úÖ

- Sexpr printer consolidated in `common`:
  - `common/src/ast/sexprPrinter.(ts|js|d.ts)` is the canonical implementation; it prints `fields` as sexpr lists and converts legacy JSON-embedded strings when possible.
  - `t2lang-phase1` now statically imports the printer from `t2lang-common/ast/sexprPrinter.js` (no runtime fallback).

- CLI AST dumping updated:
  - `--ast-before-expand` and `--ast-after-expand` flags now emit human-readable S-expression ASTs via the shared `printSexpr` helper.

- Macro & expander helpers:
  - `macroexpand` / `macroexpand1` helpers and several normalization utilities are implemented and available in Phase1's expander (with shared helpers moved into `common`/Phase0 where appropriate).

- Packaging & export stability:
  - `common/package.json` exposes the sexpr printer subpath and ships only built `.js` and `.d.ts` via the `files` field.
  - Verified local pack ‚Üí install ‚Üí consumer build flow: created `t2lang-common-0.1.0.tgz`, installed it, confirmed Node runtime import of `t2lang-common/ast/sexprPrinter.js` and successful TypeScript consumer build.
  - Removed the dynamic workspace fallback in Phase1; Phase1 now relies on the packaged `t2lang-common` exports.

- Tests (local run):
  - `t2lang-phase0` tests: **237** passing, **0** failing.
  - `t2lang-phase1` tests: **59** passing, **0** failing.

- Other fixes:
  - Replaced JSON-embedded AST `fields` with sexpr lists in printed output (printer now handles legacy cases).
  - Removed duplicated sexpr printing code from Phase1 and updated CLI helpers to use `common`.

Verification: both packages build and their test suites pass locally after the changes.

## Updated Inventory (what still lives in Phase1)
- Remaining Phase1-specific (heavier) files to consider next:
  - `src/parse/lexer.ts` ‚Äî Phase1-specific lexer behavior for quasiquote/backtick handling (likely stays in Phase1 or becomes an opt-in extension).
  - `src/expand/macroExpander.ts` ‚Äî core expander (now **thinner**; many helpers extracted to Phase0).
  - `src/api.ts` ‚Äî compile driver / Phase1 entrypoint.
  - `src/cli.ts` ‚Äî CLI glue that delegates to `t2lang-common`.
- Many other Phase1 files are thin wrappers/re-exports of Phase0 (parser adapter, resolver wrapper, typecheck wrapper, codegen re-exports, events, errors).

## Prioritized Next Steps (small, test-first, low risk) üîú
1. **Extract low-risk helpers** from `macroExpander` into Phase0 (one helper per change):
   - `flattenQuotedArgs` / splice flattening (isolated and high value)
   - `substituteAndExpand` / `evalQuote` helpers (next largest; add unit tests)
2. **Add focused tests** (‚â§10 per change) for nested splices, quoted let-binding forms, and other edge cases observed during debugging.
3. **Tighten parser hooks**: add types for parser extension points and make `attachQuotedParsers` strongly typed.
4. **Consider `expandMacros` API**: once helpers are extracted and well-tested, expose a Phase0 `expandMacros` or `MacroExpansion` facade so Phase1 can become a small adapter that only orchestrates config and top-level callbacks.

## Testing & Rollout (unchanged)
- Keep each extraction to a small, reviewable commit/PR with unit tests in Phase0 and integration tests in Phase1.
- Verify by running `cd <pkg> ; npm run lint ; npm test` in both packages before merging.

---



## Inventory (initial findings) üîé
Files and areas to inspect (candidate duplicates):
- `parse/lexer.ts` (both packages ‚Äî lexing differences around backtick/quasiquote)
- `parse/parser.ts` (Phase1 has wrappers/quoted parsing helpers)
- `expand/macroExpander.ts` (Phase1-specific, but many utilities for evaluating quoted forms may be shareable)
- `codegen/tsCodegen.ts` (Phase0 contains final codegen, Phase1 reuses this but ensure shared types)
- `tests/` (many macro tests live in Phase1: consider moving common parser/macro tests to Phase0 or to a shared test harness)

Note: Phase1 intentionally diverges where macro handling is needed; aim to keep only the adapter surface in Phase1 and extract the heavy logic into Phase0 (or `common`).

---

## Proposed Phased Workplan (small steps) ‚úÖ

### Phase A ‚Äî Preparation (small, low-risk)
- Add `DEDUPE_PLAN.md` and a short ADR if desired. (done)
- Add regression tests that capture failing cases we fixed earlier (`mkchain`, `mkblock`, `where`, `gensym` hygiene) to ensure no regressions when moving code.
- Add `TODO`-style comments in Phase1 indicating candidate extraction points.

Acceptance: tests and lint remain green after adding tests.

### Phase B ‚Äî API Extraction (medium risk)
For each duplicate area:
- Extract a well-defined helper into `t2lang-phase0/src/lib` or a new `common` package (e.g., `parseQuotedSexpr`, `normalizeQuotedAst`, `expandGensym`, `spliceMarker` handling).
- Add unit tests for the extracted helper in Phase0.
- Replace Phase1 duplicate implementation with a small shim that imports the helper.

Make changes package-by-package, commit per helper.

Acceptance: Unit tests in both packages and integration macro tests pass after each helper extraction.

### Phase C ‚Äî Parser/Tokenizer Centralization (higher risk)
- If Phase1's `Lexer` changes are small and compatible, standardize on Phase0's `Lexer` as the canonical implementation and add flags or extension points for Phase1-specific behavior.
- Introduce a `ParseOptions` interface and pass a `mode: 'phase0'|'phase1'` flag where necessary.
- Ensure `Parser` has extension hooks for Phase1 (e.g., quoted-list parsing) implemented in Phase0 behind optional callbacks.

Acceptance: No behavioral change in macro expansion tests and Phase1 can be initialized as a client of Phase0's Parser.

### Phase D ‚Äî Macro Expander Harmonization (highest risk)
- Move macro-expansion core logic into Phase0 as a public `expandMacros` API or into `common` if semantic boundaries demand it.
- Keep Phase1-specific converters/normalizers as small translators.
- Add comprehensive tests around quoted forms, splice flattening, gensym, and nested macro expansion.

Acceptance: All macro tests pass and Phase1's surface-level adapter is < 100 LOC per module for macros.

### Phase E ‚Äî Cleanup & Documentation
- Remove duplicated files, update README/MACROS.md to point to canonical logic locations.
- Add comments documenting why Phase1 remains thin and what extension points exist.
- Add a short migration note for contributors.

---

## Testing Strategy üß™
- Add regression tests to `t2lang-phase1/tests/integration/examples` for all previously problematic macros (done already for many cases).
- Add unit tests for each extracted helper inside Phase0's `tests/unit`.
- Run full `npm run lint` and `npm test` in both packages on CI for each PR.

---

## Risk & Mitigation ‚ö†Ô∏è
- Risk: Behavioral drift when extracting logic. Mitigate by adding focused tests around semantics before refactor and running full test suites after each change.
- Risk: Cyclic dependencies between packages. Mitigate by using a `common` package or keeping helpers in Phase0 with deliberate public API surface.

---

## Rollout & PR Guidelines ‚ú≥Ô∏è
- Make one helper extraction per PR (small, reviewable changes).
- Each PR must: run `cd <pkg> ; npm run lint ; npm test` and attach test logs to the PR description.
- Keep changes backwards compatible; if API breakage is inevitable, add a deprecation layer and document it.

---

## Checklist (quick) üìã
- [ ] Add regression tests for leftover macro cases (if any missing)
- [ ] Create `common` or `phase0/lib` helpers for parse/expand utilities
- [ ] Replace Phase1 duplicates with import shims and thin adapters
- [ ] Harmonize `Lexer`/`Parser` extension hooks
- [ ] Move macro expansion core to Phase0 or `common` with stable public API
- [ ] Update READMEs and add contributor notes

---

If you'd like, I can start with the **first extraction** (pick a small helper to extract, add tests, and replace a Phase1 duplicate) and submit the changes in small commits. Which helper would you like me to extract first: `parseQuotedSexpr`, `convertQuotedToAst`, or `expandGensym`? 

---

# Test & Fix & Confirm Package Export Stability

Definition: package export stability = a guaranteed, documented set of public module specifiers, entry points, and TypeScript types (the public surface) that consumers can import reliably across releases without unexpected breakage.

What it requires:

Explicit exports: exports field (and main/module) in package.json that list public entry points and subpaths.
Runtime artifacts: built JS files that match the declared export paths (no missing files).
Type declarations: .d.ts files (or "types") for every exported entry so TS consumers resolve types.
Packaged files: files or published tarball contains the JS + d.ts + any runtime assets.
Semver policy: documented versioning rules so breaking changes use major bumps.
Docs/changelog: note exported API and any deprecations.
Consumer tests: automated tests that import the package the same way real consumers will.
How to confirm locally (quick steps):

Build the package:
npm run -w common build (or ensure prepare builds on pack).
Create a tarball:
cd common && npm pack ‚Üí produces t2lang-common-<ver>.tgz.
Test runtime imports from a consumer (example shows the subpath export):
In repo root (or a temp dir):
npm i ./common/t2lang-common-0.1.0.tgz
Then in Node:
node -e "import('t2lang-common/ast/sexprPrinter.js').then(m=>console.log(typeof m.printSexpr))"
Or in the consumer workspace: install the tarball and run the consumer build/tests:
npm i ../common/t2lang-common-0.1.0.tgz && npm run -w t2lang-phase1 test
Test TypeScript resolution:
From a TypeScript consumer, run tsc --noEmit or npm run -w t2lang-phase1 build to ensure types resolve through the installed package.
Inspect tarball contents:
tar -tf t2lang-common-0.1.0.tgz ‚Äî verify exported paths, .js, and .d.ts files are included.
How to confirm in CI (recommended):

Add a job that:
Runs npm -w common run build && npm -w common pack (or npm pack).
Installs the produced tarball into a consumer job workspace (or npm install <tarball>).
Runs consumer build and test.
Optionally runs tar -tf to ensure expected files are present.
Gate merges on that job passing.
Stability practices / rules:

Document the public exports and mark internal/private modules (not exported) clearly.
Follow semver strictly: any breaking export rename => major bump.
Use deprecation shims: keep old export re-exporting new path for one minor release, logging deprecation.
Add automated compatibility tests that run before merging.
Edge cases to watch:

Monorepo paths workarounds let TypeScript resolve local source, but they don‚Äôt guarantee runtime. Always validate the published artifact (tarball) rather than only local paths.
Subpath export names must exactly match runtime file names and packaging layout (case-sensitive on some systems).
Consumers using ESM vs CJS import forms require consistent type/fields.
Quick checklist you can tick now:

Build common and run npm pack.
Confirm exports in package.json match files in the tarball.
Install tarball in a consumer and run its tests.
Run tsc in consumer to validate types.
Add CI job to repeat the above automatically.
